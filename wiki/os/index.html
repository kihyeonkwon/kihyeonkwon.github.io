<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Operating System | KIHYEON KWON</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" sizes="32x32" href="/images/favicon-32x32.png">
    <meta name="description" content="Developer based in Seoul">
    <meta name="google-site-verification" content="JyTpsE7AxKVeJeQR3P0s7_RDjE5zH6VGnIbWhSamXOQ">
    <meta property="og:image" content="https://github.com/keithkwon/keithkwon.github.io/blob/master/images/ogk.png?raw=true">
    <meta property="og:description" content="Developer based in Seoul">
    
    <link rel="preload" href="/assets/css/0.styles.20f9420f.css" as="style"><link rel="preload" href="/assets/js/app.7013d392.js" as="script"><link rel="preload" href="/assets/js/18.ca6dd341.js" as="script"><link rel="preload" href="/assets/js/1.31b6dd3f.js" as="script"><link rel="preload" href="/assets/js/8.28db9e94.js" as="script"><link rel="prefetch" href="/assets/js/10.9e4865f5.js"><link rel="prefetch" href="/assets/js/11.506f6676.js"><link rel="prefetch" href="/assets/js/12.5679cad3.js"><link rel="prefetch" href="/assets/js/13.79ba3037.js"><link rel="prefetch" href="/assets/js/14.e232e767.js"><link rel="prefetch" href="/assets/js/15.2fe2581c.js"><link rel="prefetch" href="/assets/js/16.224d8b54.js"><link rel="prefetch" href="/assets/js/17.61fcc984.js"><link rel="prefetch" href="/assets/js/19.9470fb11.js"><link rel="prefetch" href="/assets/js/2.e52989f4.js"><link rel="prefetch" href="/assets/js/20.26f5b65d.js"><link rel="prefetch" href="/assets/js/21.a2730c70.js"><link rel="prefetch" href="/assets/js/22.b0fb7101.js"><link rel="prefetch" href="/assets/js/23.41c82603.js"><link rel="prefetch" href="/assets/js/24.66485a46.js"><link rel="prefetch" href="/assets/js/25.9f41d0a5.js"><link rel="prefetch" href="/assets/js/26.3bccdde9.js"><link rel="prefetch" href="/assets/js/27.62f38e0e.js"><link rel="prefetch" href="/assets/js/28.2e121fe2.js"><link rel="prefetch" href="/assets/js/29.78d79cec.js"><link rel="prefetch" href="/assets/js/3.1ca3d9f1.js"><link rel="prefetch" href="/assets/js/30.9023b12d.js"><link rel="prefetch" href="/assets/js/31.83aac1a8.js"><link rel="prefetch" href="/assets/js/32.cd0a92af.js"><link rel="prefetch" href="/assets/js/33.847861c1.js"><link rel="prefetch" href="/assets/js/34.1c20ae0c.js"><link rel="prefetch" href="/assets/js/35.5a32a94b.js"><link rel="prefetch" href="/assets/js/36.bec1111c.js"><link rel="prefetch" href="/assets/js/37.2703c53c.js"><link rel="prefetch" href="/assets/js/38.3ac307c9.js"><link rel="prefetch" href="/assets/js/39.6358f394.js"><link rel="prefetch" href="/assets/js/40.e5f86b0d.js"><link rel="prefetch" href="/assets/js/41.ae91fe5f.js"><link rel="prefetch" href="/assets/js/42.9a586d29.js"><link rel="prefetch" href="/assets/js/43.c9c7c11c.js"><link rel="prefetch" href="/assets/js/44.497cdcd3.js"><link rel="prefetch" href="/assets/js/45.c672f81f.js"><link rel="prefetch" href="/assets/js/46.5c1a1a90.js"><link rel="prefetch" href="/assets/js/47.43e80d06.js"><link rel="prefetch" href="/assets/js/48.eaf09aed.js"><link rel="prefetch" href="/assets/js/49.9086cc53.js"><link rel="prefetch" href="/assets/js/50.210a2f01.js"><link rel="prefetch" href="/assets/js/51.7313a2d2.js"><link rel="prefetch" href="/assets/js/52.347785a0.js"><link rel="prefetch" href="/assets/js/53.511eeee1.js"><link rel="prefetch" href="/assets/js/54.a76234e1.js"><link rel="prefetch" href="/assets/js/55.f9b9c668.js"><link rel="prefetch" href="/assets/js/56.f9bf5bb1.js"><link rel="prefetch" href="/assets/js/57.d14a2d36.js"><link rel="prefetch" href="/assets/js/58.63e498bb.js"><link rel="prefetch" href="/assets/js/59.dd5901fa.js"><link rel="prefetch" href="/assets/js/6.42772b6f.js"><link rel="prefetch" href="/assets/js/60.a7188a7a.js"><link rel="prefetch" href="/assets/js/61.a6f2083c.js"><link rel="prefetch" href="/assets/js/62.fedea90e.js"><link rel="prefetch" href="/assets/js/63.43a15b29.js"><link rel="prefetch" href="/assets/js/64.46723c6a.js"><link rel="prefetch" href="/assets/js/65.e8f75fb0.js"><link rel="prefetch" href="/assets/js/66.19b5c509.js"><link rel="prefetch" href="/assets/js/67.e350e90b.js"><link rel="prefetch" href="/assets/js/68.1e519234.js"><link rel="prefetch" href="/assets/js/69.a710376e.js"><link rel="prefetch" href="/assets/js/7.43c58c68.js"><link rel="prefetch" href="/assets/js/70.a189a98e.js"><link rel="prefetch" href="/assets/js/71.211b0a44.js"><link rel="prefetch" href="/assets/js/72.b120abc5.js"><link rel="prefetch" href="/assets/js/73.11bed644.js"><link rel="prefetch" href="/assets/js/74.c53323ff.js"><link rel="prefetch" href="/assets/js/75.8b9d379a.js"><link rel="prefetch" href="/assets/js/76.fdba0a21.js"><link rel="prefetch" href="/assets/js/77.aab5f973.js"><link rel="prefetch" href="/assets/js/78.0bbb22c9.js"><link rel="prefetch" href="/assets/js/79.4bf0fbc8.js"><link rel="prefetch" href="/assets/js/80.03a54053.js"><link rel="prefetch" href="/assets/js/81.b13a4e78.js"><link rel="prefetch" href="/assets/js/82.6607be7f.js"><link rel="prefetch" href="/assets/js/83.2f567667.js"><link rel="prefetch" href="/assets/js/84.7c62f480.js"><link rel="prefetch" href="/assets/js/85.c7838f34.js"><link rel="prefetch" href="/assets/js/86.6146fcad.js"><link rel="prefetch" href="/assets/js/87.4e24b178.js"><link rel="prefetch" href="/assets/js/88.ec6aee57.js"><link rel="prefetch" href="/assets/js/89.38a39545.js"><link rel="prefetch" href="/assets/js/9.c0e2e6db.js"><link rel="prefetch" href="/assets/js/90.62bf3622.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.3d034583.js">
    <link rel="stylesheet" href="/assets/css/0.styles.20f9420f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/k.png" alt="KIHYEON KWON" class="logo"> <span class="site-name can-hide">KIHYEON KWON</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link router-link-active">
  Wiki
</a></div><div class="nav-item"><a href="/portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link router-link-active">
  Wiki
</a></div><div class="nav-item"><a href="/portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Computer Science</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/computer-science/" class="sidebar-link">Computer_Architecture</a></li><li><a href="/wiki/aws/" class="sidebar-link">AWS- Cloud Computing Setting</a></li><li><a href="/wiki/os/" aria-current="page" class="active sidebar-link">Operating System</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/os/#process-scheduling" class="sidebar-link">Process Scheduling</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#컨텍스트-스위칭" class="sidebar-link">컨텍스트 스위칭</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#inter-process-communication" class="sidebar-link">Inter-Process Communication</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#deadlock-starvation" class="sidebar-link">Deadlock &amp; Starvation</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#페이징-시스템" class="sidebar-link">페이징 시스템</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#segmentation" class="sidebar-link">Segmentation</a></li><li class="sidebar-sub-header"><a href="/wiki/os/#inode-파일-시스템" class="sidebar-link">inode 파일 시스템</a></li></ul></li><li><a href="/wiki/system-programming/" class="sidebar-link">System_Programming</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ETC</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="operating-system"><a href="#operating-system" class="header-anchor">#</a> Operating System</h1> <p><img src="/assets/img/image-20210416030912362.ced057ab.png" alt="image-20210416030912362"></p> <ul><li>OS provides <code>user interface</code> to the user.</li> <li><code>shell</code> program provides the <code>interface</code> <ul><li>Could be either <code>CLI</code> or <code>GUI</code>.</li> <li><img src="/assets/img/image-20210416032132175.cdc80d70.png" alt="image-20210416032132175"></li></ul></li> <li>OS also provides <code>user interface</code> to the application.</li> <li><code>API</code> provides the <code>interface</code> <ul><li>In the form of <code>function</code>.</li></ul></li> <li>You could say that <code>shell</code> is one type of application.</li></ul> <h3 id="system-call"><a href="#system-call" class="header-anchor">#</a> System Call</h3> <ul><li><code>System call</code> is a function provided by the OS.</li> <li>It can be called to use the OS.</li> <li>Majority of <code>API</code>s are made to call these system calls. ex) open()</li> <li>Types
<ul><li>POSIX API : Used by unix styled OS such as Linux, MacOS ...</li> <li>Window API</li></ul></li></ul> <h3 id="os-development-order"><a href="#os-development-order" class="header-anchor">#</a> OS development order</h3> <ol><li>Make an OS. (<code>kernel</code>).</li> <li>Develop <code>system call</code>.</li> <li>Develop <code>API</code> (<code>library</code>).</li> <li>Develop <code>shell</code></li> <li>develop <code>applications</code>.</li></ol> <h3 id="kernel-shell"><a href="#kernel-shell" class="header-anchor">#</a> kernel? shell?</h3> <ul><li>kernel : OS의 핵심 부분. 알맹이란 뜻을 갖고 있다.</li> <li>shell : 껍데기. kernel의 껍데기</li></ul> <h3 id="cpu-protection-rings"><a href="#cpu-protection-rings" class="header-anchor">#</a> CPU Protection Rings</h3> <ul><li>CPU도 권한모드가 있다.
<ul><li>user mode : used by applications</li> <li>kernel mode : used by OS</li></ul></li> <li>사용자 모드와 커널 모드의 뒤에는 cpu protection ring이라는 개념이 있다.</li></ul> <h2 id="process-scheduling"><a href="#process-scheduling" class="header-anchor">#</a> Process Scheduling</h2> <ul><li>Process : <code>application</code></li> <li>Scheduling : 배치처리, 시분할, 멀티태스킹 같이 <code>application</code>을  cpu에 배치하는 방법</li></ul> <h3 id="batch-processing"><a href="#batch-processing" class="header-anchor">#</a> Batch Processing</h3> <ul><li>큐 방식과 비슷한 FIFO</li> <li>하나의 프로세스가 <strong>끝나면</strong> 그 다음것을 실행시킨다.</li></ul> <h3 id="배치-처리-시스템-시분할-시스템-멀티-프로그래밍"><a href="#배치-처리-시스템-시분할-시스템-멀티-프로그래밍" class="header-anchor">#</a> 배치 처리 시스템 / 시분할 시스템 / 멀티 프로그래밍</h3> <ul><li>배치 처리는 더이상 안쓰이고 뒤 두개가 쓰이게 되었다.
<ul><li>FIFO로만 하면 어떤 프로그램은 시간이 너무 오래 걸려서 병목이 생긴다.</li> <li>음악을 재생하면서 워드를 작성하고 싶다면? (동시성)</li> <li>여러 사용자가 하나의 컴퓨터를 쓴다면? (다중 사용자)</li> <li>-&gt; 멀티 프로그래밍/시분할 시스템이 나왔다.</li></ul></li></ul> <h3 id="시분할-시스템"><a href="#시분할-시스템" class="header-anchor">#</a> 시분할 시스템</h3> <ul><li>다중 사용자 지원을 위해 컴퓨터 응답시간을 최소화 한다.</li> <li><img src="/assets/img/image-20210416040343481.df408f8f.png" alt="image-20210416040343481"></li></ul> <h3 id="멀티-태스킹"><a href="#멀티-태스킹" class="header-anchor">#</a> 멀티 태스킹</h3> <ul><li>단일 cpu에서 여러 응용 프로그램이 동시에 실행되는 것<strong>처럼</strong> 보이도록 하는 시스템. (현재의 멀티코어와 다르다)
<ul><li>음악을 들으며 문서 작성을 한다.</li> <li><img src="/assets/img/image-20210416040659049.c06e1c0a.png" alt="image-20210416040659049"></li> <li>매우 짧은시간동안 각각의 프로그램을 바꿔가면서 실행한다.
<ul><li>10~20ms 단위로 application 이 바뀐다.</li> <li>사용자에게는 동시에 실행되는 것처럼 보인다.</li> <li>기본적으로는 시분할 시스템과 원리가 비슷하다.</li></ul></li></ul></li></ul> <h3 id="멀티-태스킹-vs-멀티-프로세싱"><a href="#멀티-태스킹-vs-멀티-프로세싱" class="header-anchor">#</a> 멀티 태스킹 vs 멀티 프로세싱</h3> <ul><li>멀티 태스킹 : 단일 cpu</li> <li>멀티 프로세싱 : 여러 cpu</li> <li><img src="/assets/img/image-20210416040931900.ab0361e9.png" alt="image-20210416040931900"></li></ul> <h3 id="멀티-프로그래밍"><a href="#멀티-프로그래밍" class="header-anchor">#</a> 멀티 프로그래밍</h3> <ul><li>최대한 cpu를 많이 활용하도록 하는 시스템</li> <li>cpu에 응용프로그램이 있다고 하더라도 다른 작업을 한다고 cpu를 활용하고 있지 않을때가 있다.
<ul><li>응용 프로그램이 실행되다가 <code>파일을 읽는다</code>. 저장매체는 cpu에 비해 굉장히 느린 아이다. 이 과정에서 cpu는 쉬게 된다.
<ul><li><img src="/assets/img/image-20210416054451017.cfd28425.png" alt="image-20210416054451017"></li> <li>ssd만 되더라도 몇만 싸이클을 대기해야 된다.</li></ul></li> <li><code>프린팅을 한다</code>. 프린터가 끝날때까지 작업을 못한다면? cpu는 그냥 쉬는것이다.</li></ul></li> <li>이 때에 작업 바꿔치기를 통해서 지금 필요한 응용 프로그램을 cpu에 넣어서 작업처리 속도를 빠르게 할 수 있다.</li></ul> <h1 id="process"><a href="#process" class="header-anchor">#</a> Process</h1> <h3 id="process-2"><a href="#process-2" class="header-anchor">#</a> Process</h3> <ul><li>실행 중인 프로그램</li> <li>응용 프로그램 != 프로세스
<ul><li>응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음</li></ul></li> <li>하나의 응용 프로그램은 여러개의 프로세스와 상호작용을 하면서 실행 될 수 있다.
<ul><li>IPC</li></ul></li></ul> <h3 id="scheduler"><a href="#scheduler" class="header-anchor">#</a> Scheduler</h3> <ul><li><p>프로세스를 실행시킨다.</p></li> <li><p>어느 순서로 실행하고 교체할지 스케쥴링 알고리즘에 의해 결정된다.</p></li> <li><p>Goal :</p> <ul><li>프로세스 응답 시간을 짧게 : 시분할 시스템</li> <li>CPU 활용도를 높인다 : 멀티 프로그래밍</li></ul></li> <li><p>기본적인 스케쥴링 알고리즘들</p> <ul><li><p>FIFO  : 저장매체, 외부장치와 상호작용 없이 쭉 CPU를 사용한다.  가장 간단하고 배치처리 시스템과 유사하다.</p></li> <li><p>SJF : shortest job first.  실행시간이 가장 짧은것부터 먼저 실행.</p></li> <li><p>Priority Based :</p> <ul><li>정적 우선 순위 : 프로세스마다 우선순위를 미리 지정. 모든 프로그램에 우선순위 미리 주는게 쉽지 않다.</li> <li>동적 우선 순위 :  스케쥴러가 상황에 따라 우선순위를 동적으로 변경</li></ul></li> <li><p>Round Robin Scheduler :</p> <p><img src="/assets/img/image-20210416090855978.71b55436.png" alt="image-20210416090855978"></p> <p>시분할 시스템을 위한 스케쥴러. 특정 시간이 안끝났더라도 다시 큐 뒷편으로 보내고 다음것을 한다.</p></li></ul></li></ul> <h3 id="멀티프로그래밍과-wait"><a href="#멀티프로그래밍과-wait" class="header-anchor">#</a> 멀티프로그래밍과 wait</h3> <p><img src="/assets/img/image-20210416091702020.6123fdff.png" alt="image-20210416091702020"></p> <ul><li>위와 같은 효율적인 배치를 위해서는 cpu가 각 프로세스의 상태를 알고 있어야 한다.</li> <li><img src="/assets/img/image-20210416091810207.142db779.png" alt="image-20210416091810207"></li></ul> <h3 id="process-scheduling-2"><a href="#process-scheduling-2" class="header-anchor">#</a> Process Scheduling</h3> <p><img src="/assets/img/image-20210417101432286.97da3a78.png" alt="image-20210417101432286"></p> <ul><li>무엇부터 실행할 것인가?</li> <li>시간차에 의해 먼저 들어온쪽이 Ready State Queue에 들어온다.</li> <li>ready state에서 fifo해서 running으로 들어가고 cpu에 할당된다.</li> <li>단위가 1을 넘어가면 꼬리는 ready의 제일 끝으로 들어간다</li> <li>wait가 걸리면 block 으로 들어간다</li> <li>block이 끝나면 ready로 다시 들어간다.</li> <li><img src="data:image/png;base64,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" alt="image-20210417191317699"></li></ul> <h3 id="프로세스-구조"><a href="#프로세스-구조" class="header-anchor">#</a> 프로세스 구조</h3> <ul><li>Stack</li> <li>Heap</li> <li>Data
<ul><li>BSS : 초기화 되지 않은 전역 변수</li> <li>DATA : 초기값이 있는 전역 변수</li></ul></li> <li>Text</li></ul> <h3 id="스택-오버플로우"><a href="#스택-오버플로우" class="header-anchor">#</a> 스택 오버플로우</h3> <blockquote><p>해킹 기법 중 하나</p></blockquote> <h2 id="컨텍스트-스위칭"><a href="#컨텍스트-스위칭" class="header-anchor">#</a> 컨텍스트 스위칭</h2> <ul><li>cpu에서 돌아가는 프로세스를 바꿔주는 것을 컨텍스트 스위칭 이라고 한다.</li> <li>Context
<ul><li>Program Counter : CODE 부분에서 다음 실행될 라인을 가르킴</li> <li>Stack Pointer : STACK에서 다음 실행될 빈 공간을 가르킴</li> <li><img src="/assets/img/image-20210423150048743.c19c37a9.png" alt="image-20210423150048743"></li> <li><strong>PCB</strong>(Process Control Block)라는 특수한 공간에 Context가 저장되어 프로세스가 바뀔대마다 위치를 알려준다.
<ul><li>Process ID</li> <li>Register 값 (Program Counter, Stack Pointer)</li> <li>Scheduling Info(Process State)</li> <li>Memory Info</li> <li>와 같은 값들, 즉 프로세스 실행 상태를 캡처/구조화해서 저장</li></ul></li></ul></li></ul> <h3 id="컨텍스트-스위칭의-과정"><a href="#컨텍스트-스위칭의-과정" class="header-anchor">#</a> 컨텍스트 스위칭의 과정</h3> <ul><li>컨테스트 스위칭은 ms 단위로 일어난다.</li> <li>컨텍스트 스위칭이 짧아야지 전체 작동시간을 줄일 수 있다.</li> <li>그래서 컨텍스트 스위칭은 이식성은 떨어지더라고 속도를 높이기 위해 어셈블리어로 작성하기도 했다. 단점은 서로 다른 cpu 아키텍처가 등장할때마다 새로운 프로그램을 작석해야하고 시간이 굉장히 오래 걸렸다.</li> <li>컴파일러 등장으로 이식성을 높일 수 있었다. 속도는 조금 떨어짐</li> <li>리눅스는 각각의 cpu별로 컨텍스트 스위칭하는 프로그램을 어셈블리어로 다 짜놨다.</li></ul> <h2 id="inter-process-communication"><a href="#inter-process-communication" class="header-anchor">#</a> Inter-Process Communication</h2> <blockquote><p>프로세스간 통신하기 위한 방법 : IPC</p></blockquote> <ul><li><p>프로세스는 다른 프로세스의 공간을 직접적으로 접근 할 수 없다.</p></li> <li><p>메모리 주소는 자기 프로세스의 공간만 가르킬 수 있다.</p></li> <li><p>프로세스간 통신이 필요한 경우?</p> <ul><li>cpu core가 여러가지여서 동시에 실행 하는 경우(병렬처리)</li></ul></li> <li><p><strong>shared.txt</strong>  : 저장매체는 공유하기 때문에 파일을 하나 만들어서 업데이트 하면서 사용하는 방법이 있다. 그러나 실시간 update여부를 다른 프로세스에 알려주기 어렵고 저장매체를 굉장히 느린 방법이기 때문에 한계가 있다.</p></li></ul> <h3 id="실제-프로세스-linux"><a href="#실제-프로세스-linux" class="header-anchor">#</a> 실제 프로세스 : Linux</h3> <ul><li>리눅스의 경우 4기가 프로세스를 사용</li> <li>3~4기가 공간은 운영체제가 사용(kernel space).</li> <li>0~3기가를 프로그램이 사용(user space).</li> <li>user space는 kernel space도 접근할 수 없다.</li> <li>프로세스를 띄울때마다 운영체제를 불러오면 용량 낭비가 심하다</li> <li>그래서 사실 주소는 가상메모리고 실제 물리 메모리의 커널은 동일한 곳에서 꺼내서 쓴다.</li> <li>이러한 커널 공간을 이용해서 IPC 기법들이 나온다.</li></ul> <h3 id="다양한-ipc-기법들"><a href="#다양한-ipc-기법들" class="header-anchor">#</a> 다양한 IPC 기법들</h3> <blockquote><p>대부분이 커널 공간을 활용한다.</p></blockquote> <ol><li><p>file 사용</p></li> <li><p>Message Queue : FIFO 정책으로 데이터 전송하기 때문에 순서가 중요하다. 동일한 키값을 써야 메시지를 주고 받을 수 있다. 부모/자식 뿐만 아니라 어느 프로세스간에도 괜찮다.</p> <p><img src="/assets/img/image-20210425074843968.226801a7.png" alt="image-20210425074843968"></p></li> <li><p>Shared Memory : 커널에 메모리 공간을 만들고 해당 공간을 변수처럼 사용. FIFO가 아니고 메모리주소로 변수처럼 접근한다.</p></li> <li><p>Pipe : 단방향 통신. fork할때 부모와 자식간 통신</p> <p><img src="/assets/img/image-20210425074804231.c076d206.png" alt="image-20210425074804231"></p></li> <li><p>Signal : Unix에서 30년 이상 사용된 전통적 기법. 커널 또는 프로세스에 이벤트 발생을 알린다.</p> <ul><li></li></ul> <p><img src="/assets/img/image-20210425080115253.743746ae.png" alt="image-20210425080115253"></p></li> <li><p>Semaphore</p></li> <li><p>Socket: 네트워크 통신을 위한 기술. 기본적으로는 클라이언트와 서버등 두개의 다른 컴퓨터간의 네트워크 기반 통신 기술. 그렇지만 컴퓨터내에서 플세스간 통신에도 사용될 수 있다.</p> <p><img src="/assets/img/image-20210425080958077.06ec6a72.png" alt="image-20210425080958077"></p></li></ol> <h1 id="thread"><a href="#thread" class="header-anchor">#</a> Thread</h1> <h3 id="thread-2"><a href="#thread-2" class="header-anchor">#</a> Thread</h3> <ul><li><p>Light weight process</p></li> <li><p>프로세스 : 프로세스 간 데이터 접근 불가(ipc 사용해야함)</p></li> <li><p>쓰레드 :</p> <ul><li>하나의 프로세스에 여러개의 스레드 생성 가능.</li> <li>여러개의 스레드 동시에 실행 가능</li> <li>프로세의 데이터를 모두 접근 가능</li></ul> <p><img src="/assets/img/image-20210425083110141.9360069b.png" alt="image-20210425083110141"></p> <ul><li><strong>스택과 힙사이에 공간을 만들어서 쓰레드를 위한 스택을 따로 만들수 있다</strong>. 각각의 쓰레드 스택을 위한 Stack Pointer, Program Counter들이 다 생긴다.</li></ul> <p><img src="/assets/img/image-20210425083302967.f724d095.png" alt="image-20210425083302967"></p> <ul><li>나머지 영역들은 다 공유하고 있기 때문에 쓰레드는 별도의 ipc가 필요 없다.</li></ul></li></ul> <h3 id="multi-thread"><a href="#multi-thread" class="header-anchor">#</a> Multi Thread</h3> <p><img src="/assets/img/image-20210425083512555.7ba7315c.png" alt="image-20210425083512555"></p> <p><img src="/assets/img/image-20210425083534747.af8b7744.png" alt="image-20210425083534747"></p> <ul><li>multi tasking : 하나의 cpu에 여러가지 프로세스를 바꿔가면서 실행하면서 여러개가 동시에 실행되는 느낌을 준다.</li> <li>multi processing : 여러 cpu에 여러 프로세스를 나눠주면서 병렬 실행을 통해 실행속도를 높인다.
<ul><li>여기서 하나의 job을 여러 cpu에 나눠주는 방법이 thread를 활용한다</li> <li>thread를 여러개 만들어 멀티 코어의 활용도를 높일 수 있다.</li></ul></li></ul> <h3 id="thread의-장점"><a href="#thread의-장점" class="header-anchor">#</a> Thread의 장점</h3> <ol><li><p>사용자에 대한 응답성 향상</p> <p><img src="/assets/img/image-20210425084417304.0f57f5c6.png" alt="image-20210425084417304"></p></li> <li><p>자원 공유 효율 : 프로세스는 IPC가 필요한데 쓰레드는 필요 없다. 프로세스는 각각 생성하면 메모리를 차지하는데 쓰레드는 하나의 프로세스안에서일어나기 때문에 효율적이다.</p></li> <li><p>작업이 분리되어 코드가 간결하다. 쓰레드 하나가 함수 하나처럼 작성되기 때문이다.</p></li></ol> <h3 id="thread의-단점"><a href="#thread의-단점" class="header-anchor">#</a> Thread의 단점</h3> <ol><li><p>쓰레드 중 하나만 문제가 있어도 전체가 영향을 받는다.</p> <p><img src="/assets/img/image-20210425084808527.e3030605.png" alt="image-20210425084808527"></p></li> <li><p>쓰레드가 많으면 context switching이 잦아져서 성능이 저하된다.</p> <p>ex) 리눅스에서는 thread를 process와 동일하게 스케쥴링해서 쓰기 때문에 context switching이 자주 일어난다.</p></li></ol> <h3 id="thread-vs-process"><a href="#thread-vs-process" class="header-anchor">#</a> Thread vs Process</h3> <ul><li>프로세스는 독립적, 스레드는 프로세스의 서브셋</li> <li>프로세스는 독립 자원, 스레드는 공유 자원</li> <li>프로세스는 자신만의 주소영역, 스레드는 주소영역 공유</li> <li>프로세스는 ipc 통신 사용, 스레드는 안 사용</li></ul> <h3 id="synchronization-이슈"><a href="#synchronization-이슈" class="header-anchor">#</a> Synchronization 이슈</h3> <ul><li>스레드는 스케쥴러에 의해서 실행이 번갈아가면서 일어나는데 변수값 접근할때 순서가 엉키면 동기화 이슈가 발생하게 된다.</li> <li>디버깅이 굉장히 어렵다</li> <li>Mutual Exclusion (상호 배제)를 통해서 막는다.
<ul><li>임계 자원(critical resource) : 막아야되는 변수</li> <li>임계 영역(critical section) : 막아야 되는 코드 영역</li></ul></li></ul> <h3 id="semaphore"><a href="#semaphore" class="header-anchor">#</a> Semaphore</h3> <ul><li><p>locking mechansim에는 크게 두가지가 있다.</p> <ul><li>Mutex(binrary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있게</li> <li>Semaphore : 임계구역에 여러 스레드, counter를 통해 동시에 리소스 접근 가능한 스레드 수 제어</li></ul></li> <li><p>순서</p> <ul><li>S : 세마포어 값. 초기값만큼 여러 프로세스가 동시 임계 영역 접근 가능</li> <li>P(검사) : 임계 영역에 들어가면서 S값을 1차감. S가 0이면 <strong>대기</strong>.</li> <li>V(증가) : 임계 영역에서 나올때 S값을 1증가</li></ul></li> <li><p>대기</p> <ul><li>Busy waiting(바쁜 대기) : 프로그램에는 대기가 없기 때문에 for loop을 돌면서 대기하는 수밖에 없다. 이로인해 cpu를 사용하게 되어 성능이 저하된다.</li> <li>Waiting queue(대기 큐) : 특별한 큐를 만들어서 넣음으로써 for loop을 사용하지 않을 수 있다. sleep을 시켜놓고 s가 0보다 커지면은 wake를 시킬 수 있다.</li></ul></li></ul> <h2 id="deadlock-starvation"><a href="#deadlock-starvation" class="header-anchor">#</a> Deadlock &amp; Starvation</h2> <h3 id="deadlock"><a href="#deadlock" class="header-anchor">#</a> Deadlock</h3> <blockquote><p>두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다려서 진행이 안되는 상태</p></blockquote> <p><img src="/assets/img/image-20210425093154896.2b5eb82f.png" alt="image-20210425093154896"></p> <ul><li>Deadlock 발생 조건
<ol><li>Mutual Exclusion : 프로세스들이 자원에 대한 배타적 통제권 요구</li> <li>Hold and wait : 프로세스들이 할당된 자원을 가진상태에서 다른 자원을 요구하며 대기</li> <li>No preemption : 프로세스들끼리 자원을 뺏을 수 없다.</li> <li>Circular wait : 각프로세스는 <strong>순환적</strong>으로 자원을 요구한다.</li></ol></li></ul> <h3 id="starvation"><a href="#starvation" class="header-anchor">#</a> Starvation</h3> <blockquote><p>프로세의 우선순위가 낮아서 자원을 계속 할당 받지 못하는 상태</p></blockquote> <ul><li><p>Deadlock은 여러 프로세스가 동일 자원 점유를 요청할때 발생</p></li> <li><p>Starvation은 동일 자원 점유를 위해 경쟁시 특정 프로세스는 영원히 자원할당이 안되는 경우를 의미.</p></li> <li><p>우선순위를 수시로 변경 or  오래 기다리면 우선순위를 높여주는 방법으로 해결 가능.</p></li></ul> <h1 id="가상-메모리"><a href="#가상-메모리" class="header-anchor">#</a> 가상 메모리</h1> <ul><li><p>리눅스는 하나의 프로세스가 4gb</p></li> <li><p>통상 메모리는 8gb, 16gb</p></li> <li><p>그러면 멀티프로세싱을 어떻게 하는가? 한번에 두개, 네개밖에 불가능?</p></li> <li><p>실제로는</p> <p><img src="/assets/img/image-20210425095224562.85707b35.png" alt="image-20210425095224562"></p> <p>이런식으로 쓴다. 이것을 가상메모리라고 한다.</p></li> <li><p>여러 프로세스를 동시에 실행하는 경우에 필요하다.</p></li> <li><p>기본 아이디어</p> <p><img src="/assets/img/image-20210425095543296.1ed6bb03.png" alt="image-20210425095543296"></p> <ul><li>프로세스는 가상 주소를 사용하고 실제 해당주소에서 IO/write할때 물리주소로 바꿔주면 된다</li> <li>가상 주소 : 프로세스가 참조하는 주소</li> <li>가상 메모리 : 가상 주소와 물리 주소를 변환해 준다.
<ul><li>MMU (Memory management unit) : 가상주소 물리주소를 변환해주는 하드웨어를 제공해서 속도를 빠르게 한다.</li></ul></li> <li>물리 주소 : 실제 메모리 주소</li></ul></li></ul> <h2 id="페이징-시스템"><a href="#페이징-시스템" class="header-anchor">#</a> 페이징 시스템</h2> <blockquote><p>가상 메모리에서 가장 많이 쓰이는 메커니즘 중 하나</p></blockquote> <ul><li><p>페이징 개념</p> <ul><li>크기가 동일한 <strong>페이지</strong>로 가상주소와 물리주소를 관리</li> <li>하드웨어 지원이 필요
<ul><li>intel x86에서는 4kb, 2mb, 1gb 지원</li></ul></li> <li>리눅스에서는 4kb 페이지 사용</li> <li>페이지 번호 기반으로 가상/물리 주소 매핑한다.</li></ul></li> <li><p>PCB에 Page Table 구조체를 가르키는 주소가 있음</p> <p><img src="/assets/img/image-20210425100138224.1e159dd2.png" alt="image-20210425100138224"></p></li> <li><p><img src="/assets/img/image-20210425100919954.a05af043.png" alt="image-20210425100919954"></p></li></ul> <h3 id="다중-단계-페이징-시스템"><a href="#다중-단계-페이징-시스템" class="header-anchor">#</a> 다중 단계 페이징 시스템</h3> <ul><li>4kb 짜리 c프로그램을 만들었는데 4기가를 다 써야 하는가?</li> <li>데이터가 있는 영역만 페이지를 만드는 것을 다중 단계 페이징 시스템이라고 한다.</li> <li><img src="/assets/img/image-20210425195819753.07086502.png" alt="image-20210425195819753"></li> <li><img src="/assets/img/image-20210425195855733.1292d5d6.png" alt="image-20210425195855733"></li> <li>메모리 접근 무려 세번이나 해야돼서 굉장히 느리다.</li> <li><img src="/assets/img/image-20210425195955130.6e893745.png" alt="image-20210425195955130"></li> <li>Translation Lookalike Buffer : 캐쉬. 최근 변환한 가상메모리-물리메모리가 저장돼있어서 page table 위해 메모리 접근 없이 바로 메모리에 갈 수 있다.</li></ul> <h3 id="페이징-시스템과-공유-메모리"><a href="#페이징-시스템과-공유-메모리" class="header-anchor">#</a> 페이징 시스템과 공유 메모리</h3> <p><img src="/assets/img/image-20210425200219393.210bc421.png" alt="image-20210425200219393"></p> <ul><li><p>프로세스마다 1기가씩 운영체제 메모리를 가지고 있다면 굉장히 아깝다</p></li> <li><p>그렇지만 물리메모리를 가르키는 부분은 동일하기 때문에 사실 아깝지 않다.</p></li> <li><p>이런것이 페이징 시스템을 통해서 구현이 될 수 있다.</p></li> <li><p>또한 forking을 할때 실제로 복사하지 않고 그냥 page table을 통해서 동일 부분을 가르키게 한다.</p></li> <li><p>write를 하게 된다면 그때서야 복사 후 page pointer를 변경하는 방법으로 진짜 복사를 시작한다</p> <p><img src="/assets/img/image-20210425200450527.8e45733f.png" alt="image-20210425200450527"></p></li></ul> <h3 id="demand-paging"><a href="#demand-paging" class="header-anchor">#</a> Demand Paging</h3> <ul><li>프로세스의 모든 데이터를 메모리에 적재하지 않고 실행 중 필요할때만 메모리에 적재함.</li> <li>anticipatory paging(선행 페이징)과 반대개념이다.</li></ul> <h3 id="page-fault-interrupt"><a href="#page-fault-interrupt" class="header-anchor">#</a> Page fault interrupt</h3> <ul><li>페이지가 물리 메모리에 없을 때 발생</li> <li>page fault 인터럽가 일어나면 해당 페이지를 물리 메모리에 올림</li> <li>demand paging을 위한 기본 기술임</li></ul> <h3 id="전체-과정"><a href="#전체-과정" class="header-anchor">#</a> 전체 과정</h3> <p><img src="/assets/img/image-20210425200915539.c5e5c759.png" alt="image-20210425200915539"></p> <ol><li>cpu가 virtual address 요청
<ol><li>먼저 TLB를 확인한다</li></ol></li> <li>없다면 CR3 레지스터를 이용해서 page table에 접근</li> <li>page table에서 valid/invalid 비트를 통해 물리 메모리 저장여부를 확인한다
<ul><li>저장이 돼있다면 물리메모리 주소를 리턴하고 메모리에 접근가능</li> <li>없다면은 page fault interrupt가 일어난다
<ul><li>IDT에 간다</li> <li>page fault번호를 통해 os의 함수를 갖고온다</li></ul></li></ul></li> <li>OS가 실행 프로세스에서 데이터를 갖고와서</li> <li>데이터를 메모리에 올려준다</li> <li>page table을 업데이트 해준다.</li> <li>cpu에 다시실행하라고 알려준다</li></ol> <blockquote><p>딱 봐도 tlb에서 바로 하는것보다 매우 느리다. 페이지 폴트가 자주 일어나면 시간이 오래 걸린다. 그렇지만 미리 예측해서 물리 메모리에 올리는 것은 신의 영역이다. 이를 해결하기위한 여러 알고리즘이 있다.</p></blockquote> <h3 id="페이지-교체-정책"><a href="#페이지-교체-정책" class="header-anchor">#</a> 페이지 교체 정책</h3> <blockquote><p>여러 프로세스가 있을때 물리메모리를 누가 쓸 것인가?</p></blockquote> <ul><li>다양한 알고리즘이 가능하다. 단순하게 FIFO를 생각할 수 있다.</li> <li>최적 페이지 교체 알고리즘 : 불가능하다. 이상향.
<ul><li><img src="/assets/img/image-20210425201905203.c0ce8293.png" alt="image-20210425201905203"></li> <li>이때 3번을 4번으로 교체하는 것이 가장 이상적이다.</li> <li>그렇지만 예측 불가.</li></ul></li> <li>LRU : 가장 오래전에 쓴 페이지를 없앤다.</li> <li>LFU : 가장 적게 사용된 페이지를 없앤다.</li></ul> <h3 id="thrashing"><a href="#thrashing" class="header-anchor">#</a> Thrashing</h3> <p><img src="/assets/img/image-20210425202411015.50092e26.png" alt="image-20210425202411015"></p> <ul><li>page fault, page swap만 자주일어나서 실제로는 뭔가를 하지 못하는 단계</li> <li>프로그램을 너무 많이 띄워놓으면 안된다.</li> <li>많이 하고싶으면 메모리를 추가로 달아줘야한다.</li></ul> <h2 id="segmentation"><a href="#segmentation" class="header-anchor">#</a> Segmentation</h2> <ul><li>가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할</li> <li>이에 비해 페이징은 같은 크기의(4kb) 블록으로 분할</li> <li>80296이라는 cpu가 보호모드(protection ring)을 지원하고 kernel/user를 지원하게 됐다.</li> <li>이로 인해 기존의 cpu소프트웨어는 지원하지 않게 됐다.</li> <li>이를 실행하기위해서 호환모드를 만들었다.</li> <li>부팅시에 운영체제가 리얼모드로 실행이되고 그 이후 보호모드가 된다.</li> <li>이게 인텔의 x86이며 최대 1gb 프로세스 사용, 세그먼트로 나누게된다.</li> <li><img src="/assets/img/image-20210425202749098.b3d7fa43.png" alt="image-20210425202749098"></li> <li>페이징 시스템과 거의 유사하다.</li> <li><img src="/assets/img/image-20210425202845806.2cbe290c.png" alt="image-20210425202845806"></li> <li>페이징 기법은 4kb를 다 채우지 못하면 공간 낭비가 발생</li> <li>세그멘테이션 기법은 물리 메모리가 원하는 크기의 연속 메모리를 제공해주지 못하면 문제가 생긴다.</li> <li>리눅스는 다양한 cpu를 다 지원하기 때문에 기본인 페이징 기법을 기반으로 구현돼있다.</li></ul> <h1 id="file-system"><a href="#file-system" class="header-anchor">#</a> File system</h1> <blockquote><p>운영체제가 저장매체이 파일을 쓰기위한 자료구조/알고리즘</p></blockquote> <h3 id="파일-시스템이-만들어진-이유"><a href="#파일-시스템이-만들어진-이유" class="header-anchor">#</a> 파일 시스템이 만들어진 이유?</h3> <ul><li>0과 1을 어떻게 저장할 것인가?
<ul><li>비트로 관리하기에는 너무 양이 많다.</li> <li>블록 단위(4kb)로 관리하기로 한다.</li></ul></li> <li>사용자가 블록 고유 번호 관리할수없다.</li> <li>추상화를 통해 파일을 만들어야 한다.  파일은 블록단위를 관리한다.</li> <li>저장의 효율적 방법?
<ul><li>연속적인게 좋을 것 같았다</li> <li>근데 보니까 파일 사이즈가 변경되기때문에 불연속 공간 저장 기능 지원이 필요하다. -&gt;외부 단편화 문제
<ul><li>블록 체인 : 블록을 링크드 리스트로 연결. 첫번째 블록의 주소를 갖고있으면 그 블록에 다음 블록의 주소가 저장돼있어서 찾을 수 있다. 문제는 끝 블록을 찾으려면 처음부터 다 가야되기 때문에 단점이 있다.</li> <li>인덱스 블록 기법 : 각 블록의 주소를 별도로 저장해놔서 원하면 바로 갈수있게 저장</li></ul></li></ul></li></ul> <h3 id="다양한-파일-시스템"><a href="#다양한-파일-시스템" class="header-anchor">#</a> 다양한 파일 시스템</h3> <ul><li><p>Windows : FAT, FAT32, NTFS</p> <ul><li>블록 위치를 FAT이라는 자료구조에 저장.</li></ul></li> <li><p>Linux(unix) : ext2, ext3, ext4</p> <ul><li>인덱스 블록 기법인 inode 방식을 사용</li></ul></li> <li><p>그러나 시스템콜이 파일 시스템에 따라 바뀌면 너무 복잡하기 때문에 시스템함수는 동일하게 호출하면 알아서 처리해준다. 내부적으로는 파일 시스템 마다 다르다.</p> <p><img src="/assets/img/image-20210425205812306.d449a9ab.png" alt="image-20210425205812306"></p></li></ul> <h2 id="inode-파일-시스템"><a href="#inode-파일-시스템" class="header-anchor">#</a> inode 파일 시스템</h2> <ul><li>기본 구조
<ul><li>수퍼 블록 : 파일 시스템 정보</li> <li>아이노드 블록 : 파일 상세 정보 (메타데이터라고도 함. pcb에 저장)</li> <li>데이터 블록 : 실제 데이터 (4kb 단위)</li></ul></li> <li>파일은 inode 고유값에 의해 관리된다. 파일 이름은 inode 번호와 매칭.
<ul><li>프로세스 생성 -&gt; 프로세스 id 생성 -&gt; pcb에 저장 -&gt; 관리</li> <li>파일 생성 -&gt; inode 번호 생성 -&gt; inode블록 생성 -&gt; 관리</li></ul></li></ul> <h3 id="inode-구조"><a href="#inode-구조" class="header-anchor">#</a> inode 구조</h3> <p><img src="/assets/img/image-20210425210232793.c150ad87.png" alt="image-20210425210232793"></p> <ul><li>inode 기반 메타 데이터 : 권한, 소유자, 사이즈, 생성시간, 저장 위치 등 (위쪽 네블록)</li> <li>direct block : 데이터 블록의 주소를 갖고 있다. 12개.</li></ul> <p><img src="/assets/img/image-20210425210501207.87cbd767.png" alt="image-20210425210501207"></p> <ul><li>direct block은 12개. 가르키는 data는 1kb~4kb정도다. 그러면 전체용량이 48kb밖에 안된다고? 동영상 파일은 몇기간데 어떻게 하는가. 그래서 아래 세가지 블록들이 있다.</li></ul> <p><img src="/assets/img/image-20210425210802435.f707ad19.png" alt="image-20210425210802435"></p> <ul><li>direct block pointer에는 pointer를 1024개 저장함으로써 1000배의 데이터를 저장할 수 있다.</li> <li>이를 반복하는 double과 triple을 통해 큰 용량을 저장할 수 있다.</li></ul> <h3 id="directory-entry"><a href="#directory-entry" class="header-anchor">#</a> directory entry</h3> <p>/home/ubuntu/link.txt</p> <ul><li>dentry라고 한다.</li> <li>각 엔트리는 해당 디렉토리 파일/ 디렉토리 정보를 갖고 있다.</li> <li>이를통해 해당파일의 inode를 얻게 된다.</li></ul> <h3 id="가상-파일-시스템"><a href="#가상-파일-시스템" class="header-anchor">#</a> 가상 파일 시스템</h3> <ul><li>전통적 unix에서 파일 시스템 인터페이스르 확장해서 네트워크까지 적용한다.</li></ul> <p><img src="/assets/img/image-20210425211126049.6388dcc2.png" alt="image-20210425211126049"></p> <ul><li>모든 디바이스를 파일처럼 다룰수있게 만들었다.</li> <li>마우스, 키보드, 모든 자원을 추상화시켜서 파일 인터페이스로 활용한다.</li> <li>모든 인터렉션은 파일을 읽고 쓰는 것처럼 이루어져있다.</li></ul> <h1 id="booting"><a href="#booting" class="header-anchor">#</a> Booting</h1> <blockquote><p>컴퓨터를 키는 동작</p></blockquote> <p><img src="/assets/img/image-20210425211943467.bca01bef.png" alt="image-20210425211943467"></p> <ul><li>Boot program : 운영체제 커널을 Storage에서 물리 메모리로 복사하고 커널의 처음 실행위치로 pc를 가져다 놓는 프로그램</li> <li>pc 부팅시 메모리는 텅 비어 있다.</li> <li>그렇지만 모든 프로그램은 메모리에서 cpu로 가면서 실행된다.</li> <li>텅비어있으면 어떤 프로그램이 운영체제를 메모리로 가져온단 말인가?</li> <li>ROM : 특별한 램으로 컴퓨터가 꺼져도 메모리가 남아있으며 BIOS 프로그램이 들어있다.</li> <li>컴퓨터가 켜지면 cpu는 rom의 특정 주소를 실행한다. 미리 매핑이 되어있다. (FFFF0H 라고 설정돼있음)</li> <li>그러면 bios의 일부가 실행된다. (느림)</li> <li>이게 bios프로그램 전체를 메모리에 올리게 된다. (이제 빨라짐)</li> <li>bios 프로그램은
<ul><li>하드웨어 초기화</li> <li>저장매체(hdd, ssd) 맨앞의 MBR(Master Boot Record)를 찾아가서 읽어온다. 이게 부트 로더 라는 프로그램이다.</li> <li>부트 로더를 이제 메모리에서 실행시킨다. 여기엔 파티션 테이블이란게 들어가있다.(C:/, D:/, /). 드라이브 정보들을 갖고와서 메인 파티션이 뭔지 알게된다.</li> <li>부트 로더는 메인 파티션의 부트 섹터라는 주소로 간다. 이안에 부트 코드가 있다.</li> <li>부트 코드를 갖고와서 해당 파티션의 <strong>커널 이미지</strong>(실행파일)을 메모리에 갖고온다.</li> <li>그뒤 커널이미지가 실행되면서 윈도우 로딩화면이 시작된다.</li></ul></li></ul> <h1 id="가상-머신"><a href="#가상-머신" class="header-anchor">#</a> 가상 머신</h1> <ul><li><p>하드웨어를 emulate하는 기술</p></li> <li><p>종류는 두가지로 나뉜다</p></li> <li><p>Type 1 : 하드웨어 위에 VMM(혹은 하이퍼 바이저)라는 SW가 설치되어있고 그 위에 VM들이 돌아간다.</p> <p><img src="/assets/img/image-20210508233302147.d53100bf.png" alt="image-20210508233302147"></p></li> <li><p>Type 2 : 하드웨어에 일반적 OS가 설치돼 있고 거기에 VMM이 설치되어 있다.</p> <p><img src="/assets/img/image-20210508233343867.bfe5289c.png" alt="image-20210508233343867"></p></li> <li><p>역시 Type 1 이 더 성능이 좋다.</p></li> <li><p>전가상화 반가상화로 나눌 수 있다.</p> <ul><li>전가상화 : VMM(하이퍼바이저)이 하드웨어처럼 동작. 가상머신 os는 자기가 가상머신인줄 모름. 따라서 VM의 os는 기존의 os를 사용한다.</li> <li>반가상화 : VM의 OS가 자기가 가상머신인걸 인지한다. 하드웨어와 직접 통신이 가능하다.  VMM이 통역사가 아니라 리소스 관리만 하게 된다.</li> <li>반가상화가 성능이 더 좋지만 OS를 수정해야되고 복잡도가 올라간다. 최근에는 전가상화가 선호된다.</li></ul></li> <li><p>VMWare : Type2 소프트웨어인데 인기가 좋다.</p></li> <li><p>KVM : AWS에서 자주 쓰이는 Type1 소프트웨어. AWS에 100대의 컴퓨터를 10000명의 사용자가 쓰려면 10000개의 가상머신을 띄우게 된다.</p> <p><img src="/assets/img/image-20210508233854386.bd3d3151.png" alt="image-20210508233854386"></p> <ul><li>리눅스커널에서 ioctl이라는 명령어로 하드웨어에 직접 명령어를 내린다. 그래서 가상 cpu,  즉 vCPU를 만들 수 있다.</li></ul></li></ul> <h3 id="docker"><a href="#docker" class="header-anchor">#</a> Docker</h3> <ul><li>가상 머신은 HW를 가상화 했다.</li> <li>Docker는 커널을 추상화 한다.
<ul><li>리눅스를 처음 설치했을때와 유사한 실행환경을 만들어 주는 리눅스 컨테이너 기술 기반</li> <li>경량 이미지로 실행 환경을 통째로 백업, 실행 가능</li></ul></li></ul> <h3 id="java-virtual-machine"><a href="#java-virtual-machine" class="header-anchor">#</a> Java Virtual Machine</h3> <ul><li>가상 머신과 달리 응용 프로그램 레벨에서 가상화 한다.</li> <li>자바 컴파일러는 cpu dependency 가 없는 bytecode를 만든다.</li> <li>JVM은 이 바이트 코드를 각 운영체제에 맞게 해준다.</li></ul> <h1 id="linux"><a href="#linux" class="header-anchor">#</a> Linux</h1> <p><img src="/assets/img/image-20210509001731349.4da8b750.png" alt="image-20210509001731349"></p> <ul><li>shell : 사용자의 명령을 해석해서 커널에 명령을 요청해주는 역할.
<ul><li>Bourne-Again Shell(bash) : 리눅스의 디폴트</li> <li>Bourne Shell : sh</li> <li>C Shell : csh</li> <li>Korn Shell : ksh 유닉스에서 많이 사용됨</li></ul></li> <li>process management
<ul><li>멀티 프로세싱</li> <li>스케쥴러</li></ul></li> <li>memory management :
<ul><li>가상메모리 : page기반 메모리 관리</li></ul></li> <li>IO device management :
<ul><li>virtual file system을 통해 외부장치를 관리한다.</li></ul></li></ul> <h1 id="android"><a href="#android" class="header-anchor">#</a> Android</h1> <p><img src="/assets/img/image-20210509005145075.d6eb9b8c.png" alt="image-20210509005145075"></p> <ul><li>리눅스 기반</li> <li>자바를 쓰기 때문에 JVM이 필요하다 = 런타임</li> <li>2번과 3번을 합쳐서 안드로이드라고 볼 수 있다.</li> <li>OS는 리눅스OS에 안드로이드 플랫폼을 합친것이 안드로이드 스마트폰이라고 할 수 있다.</li></ul> <h1 id="iot"><a href="#iot" class="header-anchor">#</a> IOT</h1> <p><img src="/assets/img/image-20210509005648543.760fa8c4.png" alt="image-20210509005648543"></p> <ul><li>초소형이며 기능 최소화</li> <li>멀티태스킹, 보호모드, 커널모드, 가상메모리, 파일시스템 모두 없을 수 있다.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/aws/" class="prev">
        AWS- Cloud Computing Setting
      </a></span> <span class="next"><a href="/wiki/system-programming/">
        System_Programming
      </a>
      →
    </span></p></div>  <div class="back"><a href="/wiki" class="back-span">Back to list</a></div> <div class="theme-default-content"><!----></div></main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7013d392.js" defer></script><script src="/assets/js/18.ca6dd341.js" defer></script><script src="/assets/js/1.31b6dd3f.js" defer></script><script src="/assets/js/8.28db9e94.js" defer></script>
  </body>
</html>
