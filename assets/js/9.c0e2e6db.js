(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{674:function(t,a,i){t.exports=i.p+"assets/img/image-20210514095825270.5691ac4f.png"},675:function(t,a,i){t.exports=i.p+"assets/img/image-20210514095926418.1c20f95f.png"},676:function(t,a,i){t.exports=i.p+"assets/img/image-20210514102946215.9bd8f025.png"},677:function(t,a,i){t.exports=i.p+"assets/img/image-20210514103335257.f681d98c.png"},678:function(t,a,i){t.exports=i.p+"assets/img/image-20210514103459479.a99abbb2.png"},679:function(t,a,i){t.exports=i.p+"assets/img/image-20210514120358706.ba33b5fc.png"},680:function(t,a,i){t.exports=i.p+"assets/img/image-20210514124801574.6ef6dfe2.png"},681:function(t,a,i){t.exports=i.p+"assets/img/image-20210514121736470.556a0b49.png"},682:function(t,a,i){t.exports=i.p+"assets/img/image-20210514122038026.41f53800.png"},683:function(t,a,i){t.exports=i.p+"assets/img/image-20210514122147211.2cc8666c.png"},684:function(t,a,i){t.exports=i.p+"assets/img/image-20210514122430385.025525ac.png"},685:function(t,a,i){t.exports=i.p+"assets/img/image-20210514122451414.81909390.png"},686:function(t,a,i){t.exports=i.p+"assets/img/image-20210516085453897.fca26cb3.png"},687:function(t,a,i){t.exports=i.p+"assets/img/image-20210516085924064.fec5566a.png"},688:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090006588.679950fb.png"},689:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090019604.bfa46cdf.png"},690:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090038946.8e132372.png"},691:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090210362.fcc09cb3.png"},692:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090745946.18677cd6.png"},693:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090826625.1a68cdc0.png"},694:function(t,a,i){t.exports=i.p+"assets/img/image-20210516090959994.5cc5a2a6.png"},695:function(t,a,i){t.exports=i.p+"assets/img/image-20210516091133439.a1d5e0c1.png"},696:function(t,a,i){t.exports=i.p+"assets/img/image-20210516091716064.0a686c39.png"},697:function(t,a,i){t.exports=i.p+"assets/img/image-20210516091913128.84237fdc.png"},698:function(t,a,i){t.exports=i.p+"assets/img/image-20210516092812838.0820d45b.png"},699:function(t,a,i){t.exports=i.p+"assets/img/image-20210516093930705.6a057f92.png"},700:function(t,a,i){t.exports=i.p+"assets/img/image-20210516094933685.e5e2e775.png"},701:function(t,a,i){t.exports=i.p+"assets/img/image-20210516101823487.23b5f176.png"},702:function(t,a,i){t.exports=i.p+"assets/img/image-20210516102223062.4507415d.png"},703:function(t,a,i){t.exports=i.p+"assets/img/image-20210525212305992.69d0fc2e.png"},704:function(t,a,i){t.exports=i.p+"assets/img/image-20210525214853635.48c3f488.png"},705:function(t,a,i){t.exports=i.p+"assets/img/image-20210523142139281.dbfe665e.png"},706:function(t,a,i){t.exports=i.p+"assets/img/image-20210523144544670.832dd8a2.png"},707:function(t,a,i){t.exports=i.p+"assets/img/image-20210523151502261.879964ac.png"},708:function(t,a,i){t.exports=i.p+"assets/img/image-20210523145355776.318c163f.png"},709:function(t,a,i){t.exports=i.p+"assets/img/image-20210523155205293.bac806cb.png"},710:function(t,a,i){t.exports=i.p+"assets/img/image-20210523162042852.96a0daf3.png"},711:function(t,a,i){t.exports=i.p+"assets/img/image-20210523162744421.73854037.png"},712:function(t,a,i){t.exports=i.p+"assets/img/image-20210523163656150.0189c2a8.png"},713:function(t,a,i){t.exports=i.p+"assets/img/image-20210523164027102.8772f0f1.png"},714:function(t,a,i){t.exports=i.p+"assets/img/image-20210523164048256.37d2ca1f.png"},715:function(t,a,i){t.exports=i.p+"assets/img/image-20210523164455713.f63c21f2.png"},716:function(t,a,i){t.exports=i.p+"assets/img/image-20210527180408297.90e66795.png"},998:function(t,a,i){"use strict";i.r(a);var v=i(45),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"computer-architecture"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computer-architecture"}},[t._v("#")]),t._v(" Computer_Architecture")]),t._v(" "),v("h1",{attrs:{id:"understanding-the-computer-system"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#understanding-the-computer-system"}},[t._v("#")]),t._v(" Understanding the Computer system")]),t._v(" "),v("h2",{attrs:{id:"computer-components"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computer-components"}},[t._v("#")]),t._v(" Computer Components")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("CPU")]),t._v(" "),v("ul",[v("li",[t._v("CPU/MPU (MPU는 CPU를 여러개 묶어놓음)")]),t._v(" "),v("li",[v("img",{attrs:{src:i(674),alt:"image-20210514095825270"}})]),t._v(" "),v("li",[t._v("요즘은 Integrated Circuit인 마더보드에 탑재돼있다.")]),t._v(" "),v("li",[v("img",{attrs:{src:i(675),alt:"image-20210514095926418"}})]),t._v(" "),v("li",[t._v("MPU(Micro Processor Unit)\n"),v("ul",[v("li",[t._v("CPU를 LSI(고밀도 집적회로)화 한 통합장치")]),t._v(" "),v("li",[t._v("CISC : Complex Instruction Set Computer. 기본 기능들은 반복적이고 패턴이 일정하므로 이걸 소프트웨어로 안하고 HW로 하겠다는 MPU.")]),t._v(" "),v("li",[t._v("RISC : Reduced Instruction Set Computer. 반대 개념.")]),t._v(" "),v("li",[t._v("Bit Slice MPU : 두 종류를 적절히 쪼개서 조합시킨다.")])])]),t._v(" "),v("li",[t._v("사물 인터넷 디바이스 HW -\n"),v("ul",[v("li",[t._v("아두이노 : 2005년 이탈리아에서 탄생. 오픈소스 HW 플랫폼.")]),t._v(" "),v("li"),t._v(" "),v("li",[v("img",{attrs:{src:i(676),alt:"image-20210514102946215"}})]),t._v(" "),v("li",[t._v("Raspberry Pi : 영국에서 만듬. 훨씬 더 컴퓨터")])])])])]),t._v(" "),v("li",[v("p",[t._v("Peripheral")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Memory")]),t._v(" "),v("ul",[v("li",[t._v("RAM : 칠판처럼 리프레쉬. 작업대.")]),t._v(" "),v("li",[t._v("ROM : Read Only Memory. 운영체제 부팅시 사용. 지워지지 않는다.")])])]),t._v(" "),v("li",[v("p",[t._v("Auxiliary memory device")]),t._v(" "),v("p",[v("img",{attrs:{src:i(677),alt:"image-20210514103335257"}})]),t._v(" "),v("p",[v("img",{attrs:{src:i(678),alt:"image-20210514103459479"}})])]),t._v(" "),v("li",[v("p",[t._v("IO device")])])])])]),t._v(" "),v("h1",{attrs:{id:"data-expression"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#data-expression"}},[t._v("#")]),t._v(" Data Expression")]),t._v(" "),v("h2",{attrs:{id:"data-types"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[t._v("#")]),t._v(" Data Types")]),t._v(" "),v("h3",{attrs:{id:"complement-보수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#complement-보수"}},[t._v("#")]),t._v(" Complement : 보수")]),t._v(" "),v("ul",[v("li",[t._v("최대값(해당비트에서 가장 큰 표현형)을 형성하는데 서로 보완 관계에 있으면 1의 보수라고 한다.")]),t._v(" "),v("li",[t._v("Modulus를 형성하는데 보완관계에 있으면 2의 보수라고 한다.")]),t._v(" "),v("li",[t._v("example\n"),v("ul",[v("li",[t._v("3의 1의보수는 6, 2의보수는 7")]),t._v(" "),v("li",[t._v("18의 1의 보수는 81, 2의 보수는 82")])])]),t._v(" "),v("li",[t._v("2진 보수\n"),v("ul",[v("li",[t._v("1의 보수 : 자신의 수를 반대로 바꾸낟.")]),t._v(" "),v("li",[t._v("2의 보수 : 1의 보수에 +1")])])])]),t._v(" "),v("h3",{attrs:{id:"정수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#정수"}},[t._v("#")]),t._v(" 정수")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("부호와 절대치를 따로 보관한다.")]),t._v(" "),v("p",[v("img",{attrs:{src:i(679),alt:"image-20210514120358706"}})]),t._v(" "),v("ul",[v("li",[t._v("문제점 : +0과 -0이 두개 존재한다.")])])]),t._v(" "),v("li",[v("p",[t._v("해결 : 2진 보수로 정수를 표현한다.")]),t._v(" "),v("ul",[v("li",[t._v("2진 보수의 2의 보수를 취하면 0의 2의 보수는 그대로 0이되게 할 수 있다.")]),t._v(" "),v("li",[t._v("ex : 0000의 2진 보수의 2의 보수는 10000. 그러나 앞의 비트를 날려서 0000이 된다.")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:i(680),alt:"image-20210514124801574"}})]),t._v(" "),v("ul",[v("li",[t._v("10진수 표기(Unpacked Decimal)\n"),v("ul",[v("li",[t._v("연산은 할 수 없고 입출력용으로만 사용")]),t._v(" "),v("li",[t._v("1byte를 이용해 한 숫자 표현가능.\n"),v("ul",[v("li",[t._v("1byte = 8 bit = 두개의 hexa")]),t._v(" "),v("li",[t._v("첫 hexa는 무조건 F(1111) 두번째 hexa로 숫자 표현.")]),t._v(" "),v("li",[t._v("숫자의 마지막 숫자앞에만 F대신에 S")]),t._v(" "),v("li",[v("img",{attrs:{src:i(681),alt:"image-20210514121736470"}})])])])])]),t._v(" "),v("li",[t._v("10진수 연산(Packed Decimal)\n"),v("ul",[v("li",[t._v("F값 다 제거하고 S는 제일 뒤로 .")]),t._v(" "),v("li",[t._v("연산에 이용되고 입출력은 불가능하다.")])])])]),t._v(" "),v("h3",{attrs:{id:"실수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#실수"}},[t._v("#")]),t._v(" 실수")]),t._v(" "),v("p",[v("img",{attrs:{src:i(682),alt:"image-20210514122038026"}})]),t._v(" "),v("ul",[v("li")]),t._v(" "),v("h3",{attrs:{id:"bcd-binary-coded-decimal-code"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bcd-binary-coded-decimal-code"}},[t._v("#")]),t._v(" BCD(Binary Coded Decimal Code)")]),t._v(" "),v("p",[v("img",{attrs:{src:i(683),alt:"image-20210514122147211"}})]),t._v(" "),v("ul",[v("li",[t._v("입출력용이여서 연사이 안된다.")])]),t._v(" "),v("h3",{attrs:{id:"에러-검출-코드"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#에러-검출-코드"}},[t._v("#")]),t._v(" 에러 검출 코드")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("패리티 비트")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(684),alt:"image-20210514122430385"}})])]),t._v(" "),v("li",[v("p",[t._v("해밍 비트")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(685),alt:"image-20210514122451414"}})])]),t._v(" "),v("li",[v("p",[t._v("뺄셈을 보수의 덧셈으로 계산하는 법")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(686),alt:"image-20210516085453897"}})])]),t._v(" "),v("li")]),t._v(" "),v("h2",{attrs:{id:"alu-and-data-expression"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#alu-and-data-expression"}},[t._v("#")]),t._v(" ALU and Data Expression")]),t._v(" "),v("h3",{attrs:{id:"논리-게이트"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#논리-게이트"}},[t._v("#")]),t._v(" 논리 게이트")]),t._v(" "),v("blockquote",[v("p",[t._v("정해진 논리 함수를 수행하여 연산결과와 동일 값을 출력하는 하드웨어")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("스위칭 이론")]),t._v(" "),v("ul",[v("li",[t._v("1938년 C.E. Shannon 과 Bool에 의해서 만들어짐.")])])]),t._v(" "),v("li",[v("p",[t._v("논리연산 기본")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("AND")]),t._v(" "),v("p",[v("img",{attrs:{src:i(687),alt:"image-20210516085924064"}})])]),t._v(" "),v("li",[v("p",[t._v("OR")]),t._v(" "),v("p",[v("img",{attrs:{src:i(688),alt:"image-20210516090006588"}})])]),t._v(" "),v("li",[v("p",[t._v("NOT")]),t._v(" "),v("p",[v("img",{attrs:{src:i(689),alt:"image-20210516090019604"}})])]),t._v(" "),v("li",[v("p",[t._v("XOR")]),t._v(" "),v("p",[v("img",{attrs:{src:i(690),alt:"image-20210516090038946"}})])]),t._v(" "),v("li",[v("p",[t._v("반가산기")]),t._v(" "),v("p",[v("img",{attrs:{src:i(691),alt:"image-20210516090210362"}})]),t._v(" "),v("ul",[v("li",[t._v("진리표를 보면 AND와 XOR을 쓰면 반가산기를 만들 수 있다.")])])]),t._v(" "),v("li",[v("p",[t._v("전가산기")])])])]),t._v(" "),v("li",[v("p",[t._v("부울대수(Boolean Algebra)")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1854년 영국의 G.Boole이 만들었다.")])]),t._v(" "),v("li",[v("p",[t._v("교환법칙(commutative)")]),t._v(" "),v("p",[v("img",{attrs:{src:i(692),alt:"image-20210516090745946"}})])]),t._v(" "),v("li",[v("p",[t._v("결합법칙(associative)")]),t._v(" "),v("p",[v("img",{attrs:{src:i(693),alt:"image-20210516090826625"}})])]),t._v(" "),v("li",[v("p",[t._v("분배법칙(distributive)")]),t._v(" "),v("p",[v("img",{attrs:{src:i(694),alt:"image-20210516090959994"}})])]),t._v(" "),v("li",[v("p",[t._v("드모르간의 정리(De Morgan)")]),t._v(" "),v("p",[v("img",{attrs:{src:i(695),alt:"image-20210516091133439"}})])]),t._v(" "),v("li",[v("p",[t._v("Example")]),t._v(" "),v("p",[v("img",{attrs:{src:i(696),alt:"image-20210516091716064"}})])])])]),t._v(" "),v("li",[v("p",[t._v("카노 맵 ( Karnaugh) : map은 부울 함수를 바로 간소화 가능.")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("표현방법")]),t._v(" "),v("p",[v("img",{attrs:{src:i(697),alt:"image-20210516091913128"}})])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(698),alt:"image-20210516092812838"}})])])])])]),t._v(" "),v("h3",{attrs:{id:"조합-기억-논리-회로"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#조합-기억-논리-회로"}},[t._v("#")]),t._v(" 조합 & 기억 논리 회로")]),t._v(" "),v("ul",[v("li",[t._v("조합논리 회로\n"),v("ul",[v("li",[t._v("논리게이트의 집합이며 입력에 의해 조합함수 출력이 결정.")]),t._v(" "),v("li",[t._v("설계 절차\n"),v("ol",[v("li",[t._v("문제 제시")]),t._v(" "),v("li",[t._v("입출력 변수에 문자 기호 붙인다")]),t._v(" "),v("li",[t._v("입출력 관계 정의 진리표 유도")]),t._v(" "),v("li",[t._v("간소화된 부울 함수 얻는다")]),t._v(" "),v("li",[t._v("논리도 작성")])])])])]),t._v(" "),v("li",[t._v("기억회로")]),t._v(" "),v("li",[t._v("순차회로\n"),v("ul",[v("li",[t._v("조합회로에 기억회로(flip flop)이 합해져있다.")])])])]),t._v(" "),v("h1",{attrs:{id:"cpu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[t._v("#")]),t._v(" CPU")]),t._v(" "),v("h3",{attrs:{id:"내부-구조와-레지스터"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#내부-구조와-레지스터"}},[t._v("#")]),t._v(" 내부 구조와 레지스터")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("CPU의 구성요소")]),t._v(" "),v("p",[v("img",{attrs:{src:i(699),alt:"image-20210516093930705"}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Register Set : 명령어 실행에 필요한 데이터를 일정 시간 보관")])]),t._v(" "),v("li",[v("p",[t._v("Control Unit : RS간 정본전성, ALU에게 지시")])]),t._v(" "),v("li",[v("p",[t._v("ALU : 명령어 실행 위한 마이크로 연산 수행")]),t._v(" "),v("p",[v("img",{attrs:{src:i(700),alt:"image-20210516094933685"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"Computer_Architecture.assets/image-20210516100439230.png",alt:"image-20210516100439230"}})])])])]),t._v(" "),v("li",[v("p",[t._v("레지스터들의 명칭과 기능")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Program Counter : 다음 수행될 명령어가 있는 주기억장치의 주소를 기억하고 있는 레지스터")])]),t._v(" "),v("li",[v("p",[t._v("Instruction Register : PC가 지정하는 주소에 기억되어 있는 명령어를 임시 기억.")])]),t._v(" "),v("li",[v("p",[t._v("Instruction Decoder : IR에 있는 명령어를 해석하는 논리회로")])]),t._v(" "),v("li",[v("p",[t._v("Control Unit : ID가 보낸 신호에 따라 명령어 실행")])]),t._v(" "),v("li",[v("p",[t._v("general purpose register : 작업 레지스터에 보낼 DATA를 임시저장")])]),t._v(" "),v("li",[v("p",[t._v("working register : ALU에 보낼 자료와 결과를 저장")])]),t._v(" "),v("li",[v("p",[t._v("Status Register : CPU상태를 나타냄. (Z:0, S:Sign, V:overflow, C:carry, I:interrupt)")])])])])]),t._v(" "),v("h3",{attrs:{id:"명령어와-내부-구조"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#명령어와-내부-구조"}},[t._v("#")]),t._v(" 명령어와 내부 구조")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("명령어구성과 실행")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Micro operation : 레지스터에 저장된 데이터를 조작(shift, count, clear, load)하는 동작")])]),t._v(" "),v("li",[v("p",[t._v("레지스터 전송")]),t._v(" "),v("p",[v("img",{attrs:{src:i(701),alt:"image-20210516101823487"}})])]),t._v(" "),v("li",[v("p",[t._v("레지스터 전송을 나타내는 각 문장들은 전송을 수행하는 하드웨어가 구성되어 있음을 의미한다.")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(702),alt:"image-20210516102223062"}})])]),t._v(" "),v("li",[v("p",[t._v("그러나 디바이스들간 직접연결하면 복잡도가 O(n^2)로 늘어난다")])]),t._v(" "),v("li",[v("p",[t._v("그래서 버스연결(공용선)을 사용하게됐다.")])])])])]),t._v(" "),v("h3",{attrs:{id:"마이크로-명령과-alu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령과-alu"}},[t._v("#")]),t._v(" 마이크로 명령과 ALU")]),t._v(" "),v("h3",{attrs:{id:"마이크로-명령어-집합과-구성"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령어-집합과-구성"}},[t._v("#")]),t._v(" 마이크로 명령어 집합과 구성")]),t._v(" "),v("h3",{attrs:{id:"마이크로-명령-입출력과-인터럽트"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령-입출력과-인터럽트"}},[t._v("#")]),t._v(" 마이크로 명령 입출력과 인터럽트")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("시간 스케일")]),t._v(" "),v("ul",[v("li",[t._v("프로세스 : 10 micro sec")]),t._v(" "),v("li",[t._v("입출력 : 0.1s = 100,000 micro sec")]),t._v(" "),v("li",[t._v("결론적으로 전송시 끝났나 안끝났나 5000번의 플래크 체크 필요 -> 그래서 인터럽트가 필요해진다.")])])]),t._v(" "),v("li",[v("p",[t._v("인터럽트")]),t._v(" "),v("p",[v("img",{attrs:{src:i(703),alt:"image-20210525212305992"}})]),t._v(" "),v("ul",[v("li",[t._v("R이 1이면 인터럽트 발생. 마지막에 R값 초기화")]),t._v(" "),v("li",[t._v("IEN : Enable")]),t._v(" "),v("li",[t._v("FGI :")]),t._v(" "),v("li",[t._v("FGO :")])])])]),t._v(" "),v("h3",{attrs:{id:"컴퓨터-프로그래밍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#컴퓨터-프로그래밍"}},[t._v("#")]),t._v(" 컴퓨터 프로그래밍")]),t._v(" "),v("ul",[v("li",[t._v("프로그래밍 일반\n"),v("ul",[v("li",[t._v("HW")]),t._v(" "),v("li",[t._v("SW\n"),v("ul",[v("li",[t._v("시스템 SW\n"),v("ul",[v("li",[t._v("운영체제\n"),v("ul",[v("li",[t._v("job관리")]),t._v(" "),v("li",[t._v("스케쥴")]),t._v(" "),v("li",[t._v("네트워크")]),t._v(" "),v("li",[t._v("입출력")])])]),t._v(" "),v("li",[t._v("언어번역\n"),v("ul",[v("li",[t._v("컴파일러")]),t._v(" "),v("li",[t._v("어셈블러")]),t._v(" "),v("li",[t._v("인터프리터")])])]),t._v(" "),v("li",[t._v("유틸리티\n"),v("ul",[v("li",[t._v("DBMS")]),t._v(" "),v("li",[t._v("백신")]),t._v(" "),v("li",[t._v("드라이버 관리")])])])])]),t._v(" "),v("li",[t._v("응용 SW\n"),v("ul",[v("li",[t._v("어플리케이션")]),t._v(" "),v("li",[t._v("모바일 어플")])])])])])])]),t._v(" "),v("li",[t._v("기계어")]),t._v(" "),v("li",[t._v("어셈블리어\n"),v("ul",[v("li",[t._v("컴퓨터 제조 업체마다 다르다.")])])])]),t._v(" "),v("h3",{attrs:{id:"프로그래밍-언어와-실행"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#프로그래밍-언어와-실행"}},[t._v("#")]),t._v(" 프로그래밍 언어와 실행")]),t._v(" "),v("ul",[v("li",[t._v("패러다임의 변화\n"),v("ul",[v("li",[t._v("구조적 기법 : 코볼, 포트란")]),t._v(" "),v("li",[t._v("객체지향 : C++, 자바")]),t._v(" "),v("li",[t._v("컴포넌트")]),t._v(" "),v("li",[t._v("분산객체 : 컴포넌트의 클라우드화.")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:i(704),alt:"image-20210525214853635"}})]),t._v(" "),v("ul",[v("li",[t._v("네트워크 환경\n"),v("ul",[v("li",[t._v("컴퓨터는 통신기계가 되었다.")])])])]),t._v(" "),v("h1",{attrs:{id:"_4-pipeline-and-vector"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-pipeline-and-vector"}},[t._v("#")]),t._v(" 4. Pipeline and Vector")]),t._v(" "),v("h2",{attrs:{id:"병렬-처리와-파이프라인"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#병렬-처리와-파이프라인"}},[t._v("#")]),t._v(" 병렬 처리와 파이프라인")]),t._v(" "),v("p",[v("img",{attrs:{src:i(705),alt:"image-20210523142139281"}})]),t._v(" "),v("ul",[v("li",[t._v("로직은 복잡해지지만 발전한계를 뚫기위한 방안으로 제시됨.")])]),t._v(" "),v("h3",{attrs:{id:"flynn의-분류방법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flynn의-분류방법"}},[t._v("#")]),t._v(" Flynn의 분류방법")]),t._v(" "),v("blockquote",[v("p",[t._v("동시에 처리되는 명령어와 데이터 항목수에 의해 컴퓨터 시스템 구조를 파악하려는 분류 방법 제안. 외양적 행동 양식을 강조했다. 이 분류에 적합하지 않은 것이 파이프라인이다.")])]),t._v(" "),v("ol",[v("li",[t._v("SISD(Single Instruction Single Data) : 단일 명령어 흐름, 단일 데이터 흐름. 제어-처리-메모리를 가지는 단일 컴퓨터 구조.")]),t._v(" "),v("li",[t._v("SIMD : 공통 제어장치, 여러개 처리 장치. 동일한 명령어로 다른 데이터에 대해 실행 가능. 모든 프로세서가 메모리에 동시 접근 위해 다중 모듈을 가진 공유 메모리 장치가 필요.")]),t._v(" "),v("li",[t._v("MISD : 이론적으로만 연구. 양자라면 가능?")]),t._v(" "),v("li",[t._v("MIMD :  쿼드코어, 듀얼코어가 이런 방식이다.")])]),t._v(" "),v("h3",{attrs:{id:"파이프라인"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인"}},[t._v("#")]),t._v(" 파이프라인")]),t._v(" "),v("p",[v("img",{attrs:{src:i(706),alt:"image-20210523144544670"}})]),t._v(" "),v("p",[v("img",{attrs:{src:i(707),alt:"image-20210523151502261"}})]),t._v(" "),v("ul",[v("li",[t._v("T1은 네번의 작업을 하면 끝난다.")]),t._v(" "),v("li",[t._v("4개의 세그먼트 파이프 라인에서, 6개의 데스크를 수행했다.")]),t._v(" "),v("li",[t._v("T1을 완료하기 위해 4*t 만큼의 시간이 필요")]),t._v(" "),v("li",[t._v("결국 완료를 위해선\n"),v("ul",[v("li",[t._v("4*t + (6-1)t = (4+6-1)t 클럭 사이클이 걸린다.")]),t._v(" "),v("li",[t._v("generalize하면 (k+n-1)t 클럭 사이클.")])])])]),t._v(" "),v("h3",{attrs:{id:"파이프라인-vs-비파이프라인"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-vs-비파이프라인"}},[t._v("#")]),t._v(" 파이프라인 vs 비파이프라인")]),t._v(" "),v("p",[v("img",{attrs:{src:i(708),alt:"image-20210523145355776"}})]),t._v(" "),v("ul",[v("li",[t._v("n개의 테스크를 k개의 세그먼트로 분리해서 본다면?")]),t._v(" "),v("li",[t._v("파이프라인의 이론적 최대 속도 증가율은 세그먼트 수와 같다.")])]),t._v(" "),v("h2",{attrs:{id:"pipeline-구조"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pipeline-구조"}},[t._v("#")]),t._v(" Pipeline 구조")]),t._v(" "),v("h3",{attrs:{id:"파이프라인의-구현"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인의-구현"}},[t._v("#")]),t._v(" 파이프라인의 구현")]),t._v(" "),v("ul",[v("li",[t._v("하나의 프로세스를 여러 프로세스로 나눈다.")]),t._v(" "),v("li",[t._v("각 세그먼트는 분리된 프로세스를 연산하여 결과를 다음 세그먼트에게 전달해준다.")]),t._v(" "),v("li",[t._v("하나의 프로세스를 다양한 연산으로 중복할 수 있는 근간은 세그먼트마다 있는 레지스터다.  왜냐면 중간결과를 저장해야되니까!")])]),t._v(" "),v("p",[v("img",{attrs:{src:i(709),alt:"image-20210523155205293"}})]),t._v(" "),v("ul",[v("li",[t._v("업무강도가 세그먼트간에 일정해야한다.")])]),t._v(" "),v("p",[v("img",{attrs:{src:i(710),alt:"image-20210523162042852"}})]),t._v(" "),v("ul",[v("li",[t._v("이상적으로 보면 속도증가율이 세그먼트수에 근접한다.")])]),t._v(" "),v("h3",{attrs:{id:"현실적-병렬적-다중-기능-장치"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#현실적-병렬적-다중-기능-장치"}},[t._v("#")]),t._v(" 현실적 병렬적 다중 기능 장치")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("실제와 이론적 파이프라인의 차이")]),t._v(" "),v("ul",[v("li",[t._v("각 세그먼트의 연산속도가 차이가 나고 클럭은 그 중 가장 느린 세그먼트에 싱크를 맞춰야 한다.")])])]),t._v(" "),v("li",[v("p",[t._v("병렬적 다중 기능 장치")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("동일한 명령어를 반복처리해야되는 경우")]),t._v(" "),v("p",[v("img",{attrs:{src:i(711),alt:"image-20210523162744421"}})])]),t._v(" "),v("li",[v("p",[t._v("그러나 순차적인 처리는 불가능하다.")])])])]),t._v(" "),v("li",[v("p",[t._v("파이프라인 적용이 효과적인 경우")]),t._v(" "),v("ul",[v("li",[t._v("산술 파이프라인 : 연산 - 곱셈")]),t._v(" "),v("li",[t._v("명령어 파이프라인 : fetch - decode - execute")])])])]),t._v(" "),v("h3",{attrs:{id:"산술-파이프-라인"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#산술-파이프-라인"}},[t._v("#")]),t._v(" 산술 파이프 라인")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("부동 소수점 덧셈과 뺄셈을 위한 파이프 라인")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(712),alt:"image-20210523163656150"}})])]),t._v(" "),v("li",[v("p",[t._v("세그먼트 나누는 법")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("지수의 비교")])]),t._v(" "),v("li",[v("p",[t._v("가수의 정렬")])]),t._v(" "),v("li",[v("p",[t._v("가스의 덧셈 뺄셈")])]),t._v(" "),v("li",[v("p",[t._v("결과 정규화")]),t._v(" "),v("p",[v("img",{attrs:{src:i(713),alt:"image-20210523164027102"}})])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:i(714),alt:"image-20210523164048256"}})])])])])]),t._v(" "),v("h3",{attrs:{id:"명령어-파이프라인"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#명령어-파이프라인"}},[t._v("#")]),t._v(" 명령어 파이프라인")]),t._v(" "),v("ul",[v("li",[t._v("fetch -decode -exe를 동시에 실행하면서 효율적으로 하는 파이프라인")]),t._v(" "),v("li",[t._v("다만 분기가 발생한다면 현재 파이프라인을 다 비워야 한다")]),t._v(" "),v("li",[t._v("분기 이후 읽어오는 명령어는 모두 무시해야 한다.")])]),t._v(" "),v("p",[v("img",{attrs:{src:i(715),alt:"image-20210523164455713"}})]),t._v(" "),v("ul",[v("li",[t._v("fetch와 실행 장치 두개의 세그먼트 파이프라인을 만들었다 치자.\n"),v("ul",[v("li",[t._v("fetch는 que로 구성된 명령어를 fifo로 처리")]),t._v(" "),v("li",[t._v("수행시간이 서로 다르면 문제가 된다.")]),t._v(" "),v("li",[t._v("동일한 곳에서 fetch를 하면 문제가 발생한다. -> 데드락")])])])]),t._v(" "),v("h2",{attrs:{id:"파이프라인-cpu의-성능-분석"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-cpu의-성능-분석"}},[t._v("#")]),t._v(" 파이프라인 CPU의 성능 분석")]),t._v(" "),v("h3",{attrs:{id:"파이프라인-분기-예측"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-분기-예측"}},[t._v("#")]),t._v(" 파이프라인 분기 예측")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("파이프라인이 비정상 동작하는 경우")]),t._v(" "),v("ul",[v("li",[t._v("자원충돌 : 여러 세그먼트가 메모리 동시 접근 경우. 해결방안은 명령어 메모리와 데이터 메로리를 분리.")]),t._v(" "),v("li",[t._v("데이터 의존성 : 이전 명령어 수행결과가 아직 준비되지 않았을 때. 오버플로우 했을 경우에도 발생.")]),t._v(" "),v("li",[t._v("분기 곤란(branch difficulty) : 분기 명령어가 PC의 값을 변경할 때")])])]),t._v(" "),v("li",[v("p",[t._v("분기 명령어 처리")]),t._v(" "),v("ul",[v("li",[t._v("성능 저하의 주 요인")]),t._v(" "),v("li",[t._v("해결방안\n"),v("ul",[v("li",[t._v("순차적으로 처리될 명령어를 분기의 목표가 되는 명령어와 함께 저장해서 해결")]),t._v(" "),v("li",[t._v("분기 목표 버퍼(BTB) : fetch 세그먼트의 associative memory(주소가 아닌 내용으로 검색 가능한 기억장치)로 이전에 실행된 분기 명령어와 분기 목표 명령어를 저장하여 활용.")]),t._v(" "),v("li",[t._v("분기 예측\n"),v("ul",[v("li",[t._v("자주 사용되는 분기 연산은 굉장히 반복적이다.")]),t._v(" "),v("li",[t._v("예측이 맞으면 효과적인데 틀리면 페널티가 발생한다.")])])])])])])])]),t._v(" "),v("h3",{attrs:{id:"risc-processor"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#risc-processor"}},[t._v("#")]),t._v(" RISC Processor")]),t._v(" "),v("blockquote",[v("p",[t._v("Reduced Interaction Set Computer. Complex 와 반대. 파이프라인과 잘 맞아 떨어진다.")])]),t._v(" "),v("ul",[v("li",[t._v("특징\n"),v("ul",[v("li",[t._v("실행 명령어 수는 증가해도 처리 시간은 감소 가능")]),t._v(" "),v("li",[t._v("명령어의 1사이클 실행이 목표")]),t._v(" "),v("li",[t._v("온칩캐시(cpu내 메모리)를 둬서 빠르게 한다. 하드웨어적으로 구현.")]),t._v(" "),v("li",[t._v("간단한 명령 코드와 주소 지정 모드 같은걸 하드와이어")]),t._v(" "),v("li",[t._v("신속한 참조를 위해 레지스터 집합")]),t._v(" "),v("li",[t._v("실수 연산처리를 위한 별도의 코프로세서")])])])]),t._v(" "),v("h3",{attrs:{id:"파이프라인-cpu-성능-분석"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-cpu-성능-분석"}},[t._v("#")]),t._v(" 파이프라인 CPU 성능 분석")]),t._v(" "),v("ul",[v("li",[t._v("이론적으로는 세그먼트가 많으면 많을수록 좋지만")]),t._v(" "),v("li",[t._v("세그먼트가 일정해야하고")]),t._v(" "),v("li",[t._v("순차적으로 실행되어야 하고")]),t._v(" "),v("li",[t._v("명령어들 사이에 상호 의존성이 없어야 하고")]),t._v(" "),v("li",[t._v("공유 자원의 충돌이 없어야 한다.")])]),t._v(" "),v("h1",{attrs:{id:"_5-memory"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-memory"}},[t._v("#")]),t._v(" 5. Memory")]),t._v(" "),v("h2",{attrs:{id:"메모리-시스템-이해"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#메모리-시스템-이해"}},[t._v("#")]),t._v(" 메모리 시스템 이해")]),t._v(" "),v("ul",[v("li",[t._v("주기억장치 : 램")]),t._v(" "),v("li",[t._v("보조 기억장치 : SSD")]),t._v(" "),v("li",[t._v("캐쉬 메모리 : 현재 진행되고 있는 프로그램이나 사용빈도가 높은 임시데이터 저장")])]),t._v(" "),v("h2",{attrs:{id:"효율적-메모리-관리-정책"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#효율적-메모리-관리-정책"}},[t._v("#")]),t._v(" 효율적 메모리 관리 정책")]),t._v(" "),v("h2",{attrs:{id:"컴퓨터-성능-개선을-위한-메모리-관리"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#컴퓨터-성능-개선을-위한-메모리-관리"}},[t._v("#")]),t._v(" 컴퓨터 성능 개선을 위한 메모리 관리")]),t._v(" "),v("h2",{attrs:{id:"다양한-기억장치들에-대한-이해"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#다양한-기억장치들에-대한-이해"}},[t._v("#")]),t._v(" 다양한 기억장치들에 대한 이해")]),t._v(" "),v("h1",{attrs:{id:"_6-io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-io"}},[t._v("#")]),t._v(" 6. IO")]),t._v(" "),v("h2",{attrs:{id:"시스템-버스-구성-및-제어"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시스템-버스-구성-및-제어"}},[t._v("#")]),t._v(" 시스템 버스 구성 및 제어")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Peripheral Component Interconnect : PCI도 버스다.")])]),t._v(" "),v("li",[v("p",[t._v("레지스터 사이들의 연결은 n^2으로 늘어난다. 이문제 해결을 위해 버스라는 효율적인 방법을 쓴다.")]),t._v(" "),v("p",[v("img",{attrs:{src:i(716),alt:"image-20210527180408297"}})])]),t._v(" "),v("li",[v("p",[t._v("여러 종류의 버스 라인이 존재한다. 이는 버스 어댑터를 통해 둘이 연결된다.")])]),t._v(" "),v("li",[v("p",[t._v("기본적으로 커먼 버스 라인은 메모리와 cpu를 연결한다.")])]),t._v(" "),v("li",[v("p",[t._v("작동 방식")]),t._v(" "),v("ul",[v("li",[t._v("동기 : 클락에 의해 시작 정지")]),t._v(" "),v("li",[t._v("비동기 : 핸드 셰이킹을 통해서 시작 정지")])])]),t._v(" "),v("li",[v("p",[t._v("중재")]),t._v(" "),v("ul",[v("li",[t._v("직렬중재")]),t._v(" "),v("li",[t._v("병렬중재")])])])]),t._v(" "),v("h2",{attrs:{id:"입출력-연결과-주소-지정"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#입출력-연결과-주소-지정"}},[t._v("#")]),t._v(" 입출력 연결과 주소 지정")]),t._v(" "),v("h2",{attrs:{id:"입출력-수행과-인터럽트"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#입출력-수행과-인터럽트"}},[t._v("#")]),t._v(" 입출력 수행과 인터럽트")]),t._v(" "),v("h1",{attrs:{id:"_7-parallel-computing"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-parallel-computing"}},[t._v("#")]),t._v(" 7. Parallel Computing")]),t._v(" "),v("h2",{attrs:{id:"멀티-프로세서"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#멀티-프로세서"}},[t._v("#")]),t._v(" 멀티 프로세서")]),t._v(" "),v("h2",{attrs:{id:"시스템-성능-분석과-개선"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시스템-성능-분석과-개선"}},[t._v("#")]),t._v(" 시스템 성능 분석과 개선")])])}),[],!1,null,null,null);a.default=_.exports}}]);