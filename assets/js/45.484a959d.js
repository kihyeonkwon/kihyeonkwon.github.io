(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{782:function(t,e,a){"use strict";a.r(e);var v=a(45),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"computer-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computer-architecture"}},[t._v("#")]),t._v(" Computer Architecture")]),t._v(" "),a("h1",{attrs:{id:"understanding-the-computer-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#understanding-the-computer-system"}},[t._v("#")]),t._v(" Understanding the Computer system")]),t._v(" "),a("h2",{attrs:{id:"computer-components"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computer-components"}},[t._v("#")]),t._v(" Computer Components")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CPU")]),t._v(" "),a("ul",[a("li",[t._v("CPU/MPU (MPU는 CPU를 여러개 묶어놓음)")]),t._v(" "),a("li",[t._v("![image-20210514095825270](./Computer Architecture.assets/image-20210514095825270.png)")]),t._v(" "),a("li",[t._v("요즘은 Integrated Circuit인 마더보드에 탑재돼있다.")]),t._v(" "),a("li",[t._v("![image-20210514095926418](./Computer Architecture.assets/image-20210514095926418.png)")]),t._v(" "),a("li",[t._v("MPU(Micro Processor Unit)\n"),a("ul",[a("li",[t._v("CPU를 LSI(고밀도 집적회로)화 한 통합장치")]),t._v(" "),a("li",[t._v("CISC : Complex Instruction Set Computer. 기본 기능들은 반복적이고 패턴이 일정하므로 이걸 소프트웨어로 안하고 HW로 하겠다는 MPU.")]),t._v(" "),a("li",[t._v("RISC : Reduced Instruction Set Computer. 반대 개념.")]),t._v(" "),a("li",[t._v("Bit Slice MPU : 두 종류를 적절히 쪼개서 조합시킨다.")])])]),t._v(" "),a("li",[t._v("사물 인터넷 디바이스 HW -\n"),a("ul",[a("li",[t._v("아두이노 : 2005년 이탈리아에서 탄생. 오픈소스 HW 플랫폼.")]),t._v(" "),a("li"),t._v(" "),a("li",[t._v("![image-20210514102946215](./Computer Architecture.assets/image-20210514102946215.png)")]),t._v(" "),a("li",[t._v("Raspberry Pi : 영국에서 만듬. 훨씬 더 컴퓨터")])])])])]),t._v(" "),a("li",[a("p",[t._v("Peripheral")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Memory")]),t._v(" "),a("ul",[a("li",[t._v("RAM : 칠판처럼 리프레쉬. 작업대.")]),t._v(" "),a("li",[t._v("ROM : Read Only Memory. 운영체제 부팅시 사용. 지워지지 않는다.")])])]),t._v(" "),a("li",[a("p",[t._v("Auxiliary memory device")]),t._v(" "),a("p",[t._v("![image-20210514103335257](./Computer Architecture.assets/image-20210514103335257.png)")]),t._v(" "),a("p",[t._v("![image-20210514103459479](./Computer Architecture.assets/image-20210514103459479.png)")])]),t._v(" "),a("li",[a("p",[t._v("IO device")])])])])]),t._v(" "),a("h1",{attrs:{id:"data-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-expression"}},[t._v("#")]),t._v(" Data Expression")]),t._v(" "),a("h2",{attrs:{id:"data-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[t._v("#")]),t._v(" Data Types")]),t._v(" "),a("h3",{attrs:{id:"complement-보수"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#complement-보수"}},[t._v("#")]),t._v(" Complement : 보수")]),t._v(" "),a("ul",[a("li",[t._v("최대값(해당비트에서 가장 큰 표현형)을 형성하는데 서로 보완 관계에 있으면 1의 보수라고 한다.")]),t._v(" "),a("li",[t._v("Modulus를 형성하는데 보완관계에 있으면 2의 보수라고 한다.")]),t._v(" "),a("li",[t._v("example\n"),a("ul",[a("li",[t._v("3의 1의보수는 6, 2의보수는 7")]),t._v(" "),a("li",[t._v("18의 1의 보수는 81, 2의 보수는 82")])])]),t._v(" "),a("li",[t._v("2진 보수\n"),a("ul",[a("li",[t._v("1의 보수 : 자신의 수를 반대로 바꾸낟.")]),t._v(" "),a("li",[t._v("2의 보수 : 1의 보수에 +1")])])])]),t._v(" "),a("h3",{attrs:{id:"정수"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정수"}},[t._v("#")]),t._v(" 정수")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("부호와 절대치를 따로 보관한다.")]),t._v(" "),a("p",[t._v("![image-20210514120358706](./Computer Architecture.assets/image-20210514120358706.png)")]),t._v(" "),a("ul",[a("li",[t._v("문제점 : +0과 -0이 두개 존재한다.")])])]),t._v(" "),a("li",[a("p",[t._v("해결 : 2진 보수로 정수를 표현한다.")]),t._v(" "),a("ul",[a("li",[t._v("2진 보수의 2의 보수를 취하면 0의 2의 보수는 그대로 0이되게 할 수 있다.")]),t._v(" "),a("li",[t._v("ex : 0000의 2진 보수의 2의 보수는 10000. 그러나 앞의 비트를 날려서 0000이 된다.")])])])]),t._v(" "),a("p",[t._v("![image-20210514124801574](./Computer Architecture.assets/image-20210514124801574.png)")]),t._v(" "),a("ul",[a("li",[t._v("10진수 표기(Unpacked Decimal)\n"),a("ul",[a("li",[t._v("연산은 할 수 없고 입출력용으로만 사용")]),t._v(" "),a("li",[t._v("1byte를 이용해 한 숫자 표현가능.\n"),a("ul",[a("li",[t._v("1byte = 8 bit = 두개의 hexa")]),t._v(" "),a("li",[t._v("첫 hexa는 무조건 F(1111) 두번째 hexa로 숫자 표현.")]),t._v(" "),a("li",[t._v("숫자의 마지막 숫자앞에만 F대신에 S")]),t._v(" "),a("li",[t._v("![image-20210514121736470](./Computer Architecture.assets/image-20210514121736470.png)")])])])])]),t._v(" "),a("li",[t._v("10진수 연산(Packed Decimal)\n"),a("ul",[a("li",[t._v("F값 다 제거하고 S는 제일 뒤로 .")]),t._v(" "),a("li",[t._v("연산에 이용되고 입출력은 불가능하다.")])])])]),t._v(" "),a("h3",{attrs:{id:"실수"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#실수"}},[t._v("#")]),t._v(" 실수")]),t._v(" "),a("p",[t._v("![image-20210514122038026](./Computer Architecture.assets/image-20210514122038026.png)")]),t._v(" "),a("ul",[a("li")]),t._v(" "),a("h3",{attrs:{id:"bcd-binary-coded-decimal-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bcd-binary-coded-decimal-code"}},[t._v("#")]),t._v(" BCD(Binary Coded Decimal Code)")]),t._v(" "),a("p",[t._v("![image-20210514122147211](./Computer Architecture.assets/image-20210514122147211.png)")]),t._v(" "),a("ul",[a("li",[t._v("입출력용이여서 연사이 안된다.")])]),t._v(" "),a("h3",{attrs:{id:"에러-검출-코드"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#에러-검출-코드"}},[t._v("#")]),t._v(" 에러 검출 코드")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("패리티 비트")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210514122430385](./Computer Architecture.assets/image-20210514122430385.png)")])]),t._v(" "),a("li",[a("p",[t._v("해밍 비트")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210514122451414](./Computer Architecture.assets/image-20210514122451414.png)")])]),t._v(" "),a("li",[a("p",[t._v("뺄셈을 보수의 덧셈으로 계산하는 법")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210516085453897](./Computer Architecture.assets/image-20210516085453897.png)")])]),t._v(" "),a("li")]),t._v(" "),a("h2",{attrs:{id:"alu-and-data-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alu-and-data-expression"}},[t._v("#")]),t._v(" ALU and Data Expression")]),t._v(" "),a("h3",{attrs:{id:"논리-게이트"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#논리-게이트"}},[t._v("#")]),t._v(" 논리 게이트")]),t._v(" "),a("blockquote",[a("p",[t._v("정해진 논리 함수를 수행하여 연산결과와 동일 값을 출력하는 하드웨어")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("스위칭 이론")]),t._v(" "),a("ul",[a("li",[t._v("1938년 C.E. Shannon 과 Bool에 의해서 만들어짐.")])])]),t._v(" "),a("li",[a("p",[t._v("논리연산 기본")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("AND")]),t._v(" "),a("p",[t._v("![image-20210516085924064](./Computer Architecture.assets/image-20210516085924064.png)")])]),t._v(" "),a("li",[a("p",[t._v("OR")]),t._v(" "),a("p",[t._v("![image-20210516090006588](./Computer Architecture.assets/image-20210516090006588.png)")])]),t._v(" "),a("li",[a("p",[t._v("NOT")]),t._v(" "),a("p",[t._v("![image-20210516090019604](./Computer Architecture.assets/image-20210516090019604.png)")])]),t._v(" "),a("li",[a("p",[t._v("XOR")]),t._v(" "),a("p",[t._v("![image-20210516090038946](./Computer Architecture.assets/image-20210516090038946.png)")])]),t._v(" "),a("li",[a("p",[t._v("반가산기")]),t._v(" "),a("p",[t._v("![image-20210516090210362](./Computer Architecture.assets/image-20210516090210362.png)")]),t._v(" "),a("ul",[a("li",[t._v("진리표를 보면 AND와 XOR을 쓰면 반가산기를 만들 수 있다.")])])]),t._v(" "),a("li",[a("p",[t._v("전가산기")])])])]),t._v(" "),a("li",[a("p",[t._v("부울대수(Boolean Algebra)")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("1854년 영국의 G.Boole이 만들었다.")])]),t._v(" "),a("li",[a("p",[t._v("교환법칙(commutative)")]),t._v(" "),a("p",[t._v("![image-20210516090745946](./Computer Architecture.assets/image-20210516090745946.png)")])]),t._v(" "),a("li",[a("p",[t._v("결합법칙(associative)")]),t._v(" "),a("p",[t._v("![image-20210516090826625](./Computer Architecture.assets/image-20210516090826625.png)")])]),t._v(" "),a("li",[a("p",[t._v("분배법칙(distributive)")]),t._v(" "),a("p",[t._v("![image-20210516090959994](./Computer Architecture.assets/image-20210516090959994.png)")])]),t._v(" "),a("li",[a("p",[t._v("드모르간의 정리(De Morgan)")]),t._v(" "),a("p",[t._v("![image-20210516091133439](./Computer Architecture.assets/image-20210516091133439.png)")])]),t._v(" "),a("li",[a("p",[t._v("Example")]),t._v(" "),a("p",[t._v("![image-20210516091716064](./Computer Architecture.assets/image-20210516091716064.png)")])])])]),t._v(" "),a("li",[a("p",[t._v("카노 맵 ( Karnaugh) : map은 부울 함수를 바로 간소화 가능.")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("표현방법")]),t._v(" "),a("p",[t._v("![image-20210516091913128](./Computer Architecture.assets/image-20210516091913128.png)")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210516092812838](./Computer Architecture.assets/image-20210516092812838.png)")])])])])]),t._v(" "),a("h3",{attrs:{id:"조합-기억-논리-회로"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#조합-기억-논리-회로"}},[t._v("#")]),t._v(" 조합 & 기억 논리 회로")]),t._v(" "),a("ul",[a("li",[t._v("조합논리 회로\n"),a("ul",[a("li",[t._v("논리게이트의 집합이며 입력에 의해 조합함수 출력이 결정.")]),t._v(" "),a("li",[t._v("설계 절차\n"),a("ol",[a("li",[t._v("문제 제시")]),t._v(" "),a("li",[t._v("입출력 변수에 문자 기호 붙인다")]),t._v(" "),a("li",[t._v("입출력 관계 정의 진리표 유도")]),t._v(" "),a("li",[t._v("간소화된 부울 함수 얻는다")]),t._v(" "),a("li",[t._v("논리도 작성")])])])])]),t._v(" "),a("li",[t._v("기억회로")]),t._v(" "),a("li",[t._v("순차회로\n"),a("ul",[a("li",[t._v("조합회로에 기억회로(flip flop)이 합해져있다.")])])])]),t._v(" "),a("h1",{attrs:{id:"cpu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[t._v("#")]),t._v(" CPU")]),t._v(" "),a("h3",{attrs:{id:"내부-구조와-레지스터"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#내부-구조와-레지스터"}},[t._v("#")]),t._v(" 내부 구조와 레지스터")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CPU의 구성요소")]),t._v(" "),a("p",[t._v("![image-20210516093930705](./Computer Architecture.assets/image-20210516093930705.png)")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Register Set : 명령어 실행에 필요한 데이터를 일정 시간 보관")])]),t._v(" "),a("li",[a("p",[t._v("Control Unit : RS간 정본전성, ALU에게 지시")])]),t._v(" "),a("li",[a("p",[t._v("ALU : 명령어 실행 위한 마이크로 연산 수행")]),t._v(" "),a("p",[t._v("![image-20210516094933685](./Computer Architecture.assets/image-20210516094933685.png)")]),t._v(" "),a("p",[t._v("![image-20210516100439230](Computer Architecture.assets/image-20210516100439230.png)")])])])]),t._v(" "),a("li",[a("p",[t._v("레지스터들의 명칭과 기능")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Program Counter : 다음 수행될 명령어가 있는 주기억장치의 주소를 기억하고 있는 레지스터")])]),t._v(" "),a("li",[a("p",[t._v("Instruction Register : PC가 지정하는 주소에 기억되어 있는 명령어를 임시 기억.")])]),t._v(" "),a("li",[a("p",[t._v("Instruction Decoder : IR에 있는 명령어를 해석하는 논리회로")])]),t._v(" "),a("li",[a("p",[t._v("Control Unit : ID가 보낸 신호에 따라 명령어 실행")])]),t._v(" "),a("li",[a("p",[t._v("general purpose register : 작업 레지스터에 보낼 DATA를 임시저장")])]),t._v(" "),a("li",[a("p",[t._v("working register : ALU에 보낼 자료와 결과를 저장")])]),t._v(" "),a("li",[a("p",[t._v("Status Register : CPU상태를 나타냄. (Z:0, S:Sign, V:overflow, C:carry, I:interrupt)")])])])])]),t._v(" "),a("h3",{attrs:{id:"명령어와-내부-구조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#명령어와-내부-구조"}},[t._v("#")]),t._v(" 명령어와 내부 구조")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("명령어구성과 실행")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Micro operation : 레지스터에 저장된 데이터를 조작(shift, count, clear, load)하는 동작")])]),t._v(" "),a("li",[a("p",[t._v("레지스터 전송")]),t._v(" "),a("p",[t._v("![image-20210516101823487](./Computer Architecture.assets/image-20210516101823487.png)")])]),t._v(" "),a("li",[a("p",[t._v("레지스터 전송을 나타내는 각 문장들은 전송을 수행하는 하드웨어가 구성되어 있음을 의미한다.")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210516102223062](./Computer Architecture.assets/image-20210516102223062.png)")])]),t._v(" "),a("li",[a("p",[t._v("그러나 디바이스들간 직접연결하면 복잡도가 O(n^2)로 늘어난다")])]),t._v(" "),a("li",[a("p",[t._v("그래서 버스연결(공용선)을 사용하게됐다.")])])])])]),t._v(" "),a("h3",{attrs:{id:"마이크로-명령과-alu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령과-alu"}},[t._v("#")]),t._v(" 마이크로 명령과 ALU")]),t._v(" "),a("h3",{attrs:{id:"마이크로-명령어-집합과-구성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령어-집합과-구성"}},[t._v("#")]),t._v(" 마이크로 명령어 집합과 구성")]),t._v(" "),a("h3",{attrs:{id:"마이크로-명령-입출력과-인터럽트"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#마이크로-명령-입출력과-인터럽트"}},[t._v("#")]),t._v(" 마이크로 명령 입출력과 인터럽트")]),t._v(" "),a("h3",{attrs:{id:"컴퓨터-프로그래밍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#컴퓨터-프로그래밍"}},[t._v("#")]),t._v(" 컴퓨터 프로그래밍")]),t._v(" "),a("h3",{attrs:{id:"프로그래밍-언어와-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#프로그래밍-언어와-실행"}},[t._v("#")]),t._v(" 프로그래밍 언어와 실행")]),t._v(" "),a("h1",{attrs:{id:"_4-pipeline-and-vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-pipeline-and-vector"}},[t._v("#")]),t._v(" 4. Pipeline and Vector")]),t._v(" "),a("h2",{attrs:{id:"병렬-처리와-파이프라인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#병렬-처리와-파이프라인"}},[t._v("#")]),t._v(" 병렬 처리와 파이프라인")]),t._v(" "),a("p",[t._v("![image-20210523142139281](./Computer Architecture.assets/image-20210523142139281.png)")]),t._v(" "),a("ul",[a("li",[t._v("로직은 복잡해지지만 발전한계를 뚫기위한 방안으로 제시됨.")])]),t._v(" "),a("h3",{attrs:{id:"flynn의-분류방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flynn의-분류방법"}},[t._v("#")]),t._v(" Flynn의 분류방법")]),t._v(" "),a("blockquote",[a("p",[t._v("동시에 처리되는 명령어와 데이터 항목수에 의해 컴퓨터 시스템 구조를 파악하려는 분류 방법 제안. 외양적 행동 양식을 강조했다. 이 분류에 적합하지 않은 것이 파이프라인이다.")])]),t._v(" "),a("ol",[a("li",[t._v("SISD(Single Instruction Single Data) : 단일 명령어 흐름, 단일 데이터 흐름. 제어-처리-메모리를 가지는 단일 컴퓨터 구조.")]),t._v(" "),a("li",[t._v("SIMD : 공통 제어장치, 여러개 처리 장치. 동일한 명령어로 다른 데이터에 대해 실행 가능. 모든 프로세서가 메모리에 동시 접근 위해 다중 모듈을 가진 공유 메모리 장치가 필요.")]),t._v(" "),a("li",[t._v("MISD : 이론적으로만 연구. 양자라면 가능?")]),t._v(" "),a("li",[t._v("MIMD :  쿼드코어, 듀얼코어가 이런 방식이다.")])]),t._v(" "),a("h3",{attrs:{id:"파이프라인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인"}},[t._v("#")]),t._v(" 파이프라인")]),t._v(" "),a("p",[t._v("![image-20210523144544670](./Computer Architecture.assets/image-20210523144544670.png)")]),t._v(" "),a("p",[t._v("![image-20210523151502261](./Computer Architecture.assets/image-20210523151502261.png)")]),t._v(" "),a("ul",[a("li",[t._v("T1은 네번의 작업을 하면 끝난다.")]),t._v(" "),a("li",[t._v("4개의 세그먼트 파이프 라인에서, 6개의 데스크를 수행했다.")]),t._v(" "),a("li",[t._v("T1을 완료하기 위해 4*t 만큼의 시간이 필요")]),t._v(" "),a("li",[t._v("결국 완료를 위해선\n"),a("ul",[a("li",[t._v("4*t + (6-1)t = (4+6-1)t 클럭 사이클이 걸린다.")]),t._v(" "),a("li",[t._v("generalize하면 (k+n-1)t 클럭 사이클.")])])])]),t._v(" "),a("h3",{attrs:{id:"파이프라인-vs-비파이프라인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-vs-비파이프라인"}},[t._v("#")]),t._v(" 파이프라인 vs 비파이프라인")]),t._v(" "),a("p",[t._v("![image-20210523145355776](./Computer Architecture.assets/image-20210523145355776.png)")]),t._v(" "),a("ul",[a("li",[t._v("n개의 테스크를 k개의 세그먼트로 분리해서 본다면?")]),t._v(" "),a("li",[t._v("파이프라인의 이론적 최대 속도 증가율은 세그먼트 수와 같다.")])]),t._v(" "),a("h2",{attrs:{id:"pipeline-구조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipeline-구조"}},[t._v("#")]),t._v(" Pipeline 구조")]),t._v(" "),a("h3",{attrs:{id:"파이프라인의-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인의-구현"}},[t._v("#")]),t._v(" 파이프라인의 구현")]),t._v(" "),a("ul",[a("li",[t._v("하나의 프로세스를 여러 프로세스로 나눈다.")]),t._v(" "),a("li",[t._v("각 세그먼트는 분리된 프로세스를 연산하여 결과를 다음 세그먼트에게 전달해준다.")]),t._v(" "),a("li",[t._v("하나의 프로세스를 다양한 연산으로 중복할 수 있는 근간은 세그먼트마다 있는 레지스터다.  왜냐면 중간결과를 저장해야되니까!")])]),t._v(" "),a("p",[t._v("![image-20210523155205293](./Computer Architecture.assets/image-20210523155205293.png)")]),t._v(" "),a("ul",[a("li",[t._v("업무강도가 세그먼트간에 일정해야한다.")])]),t._v(" "),a("p",[t._v("![image-20210523162042852](./Computer Architecture.assets/image-20210523162042852.png)")]),t._v(" "),a("ul",[a("li",[t._v("이상적으로 보면 속도증가율이 세그먼트수에 근접한다.")])]),t._v(" "),a("h3",{attrs:{id:"현실적-병렬적-다중-기능-장치"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#현실적-병렬적-다중-기능-장치"}},[t._v("#")]),t._v(" 현실적 병렬적 다중 기능 장치")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("실제와 이론적 파이프라인의 차이")]),t._v(" "),a("ul",[a("li",[t._v("각 세그먼트의 연산속도가 차이가 나고 클럭은 그 중 가장 느린 세그먼트에 싱크를 맞춰야 한다.")])])]),t._v(" "),a("li",[a("p",[t._v("병렬적 다중 기능 장치")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("동일한 명령어를 반복처리해야되는 경우")]),t._v(" "),a("p",[t._v("![image-20210523162744421](./Computer Architecture.assets/image-20210523162744421.png)")])]),t._v(" "),a("li",[a("p",[t._v("그러나 순차적인 처리는 불가능하다.")])])])]),t._v(" "),a("li",[a("p",[t._v("파이프라인 적용이 효과적인 경우")]),t._v(" "),a("ul",[a("li",[t._v("산술 파이프라인 : 연산 - 곱셈")]),t._v(" "),a("li",[t._v("명령어 파이프라인 : fetch - decode - execute")])])])]),t._v(" "),a("h3",{attrs:{id:"산술-파이프-라인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#산술-파이프-라인"}},[t._v("#")]),t._v(" 산술 파이프 라인")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("부동 소수점 덧셈과 뺄셈을 위한 파이프 라인")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210523163656150](./Computer Architecture.assets/image-20210523163656150.png)")])]),t._v(" "),a("li",[a("p",[t._v("세그먼트 나누는 법")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("지수의 비교")])]),t._v(" "),a("li",[a("p",[t._v("가수의 정렬")])]),t._v(" "),a("li",[a("p",[t._v("가스의 덧셈 뺄셈")])]),t._v(" "),a("li",[a("p",[t._v("결과 정규화")]),t._v(" "),a("p",[t._v("![image-20210523164027102](./Computer Architecture.assets/image-20210523164027102.png)")])]),t._v(" "),a("li",[a("p",[t._v("![image-20210523164048256](./Computer Architecture.assets/image-20210523164048256.png)")])])])])]),t._v(" "),a("h3",{attrs:{id:"명령어-파이프라인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#명령어-파이프라인"}},[t._v("#")]),t._v(" 명령어 파이프라인")]),t._v(" "),a("ul",[a("li",[t._v("fetch -decode -exe를 동시에 실행하면서 효율적으로 하는 파이프라인")]),t._v(" "),a("li",[t._v("다만 분기가 발생한다면 현재 파이프라인을 다 비워야 한다")]),t._v(" "),a("li",[t._v("분기 이후 읽어오는 명령어는 모두 무시해야 한다.")])]),t._v(" "),a("p",[t._v("![image-20210523164455713](./Computer Architecture.assets/image-20210523164455713.png)")]),t._v(" "),a("ul",[a("li",[t._v("fetch와 실행 장치 두개의 세그먼트 파이프라인을 만들었다 치자.\n"),a("ul",[a("li",[t._v("fetch는 que로 구성된 명령어를 fifo로 처리")]),t._v(" "),a("li",[t._v("수행시간이 서로 다르면 문제가 된다.")]),t._v(" "),a("li",[t._v("동일한 곳에서 fetch를 하면 문제가 발생한다. -> 데드락")])])])]),t._v(" "),a("h2",{attrs:{id:"파이프라인-cpu의-성능-분석"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-cpu의-성능-분석"}},[t._v("#")]),t._v(" 파이프라인 CPU의 성능 분석")]),t._v(" "),a("h3",{attrs:{id:"파이프라인-분기-예측"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-분기-예측"}},[t._v("#")]),t._v(" 파이프라인 분기 예측")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("파이프라인이 비정상 동작하는 경우")]),t._v(" "),a("ul",[a("li",[t._v("자원충돌 : 여러 세그먼트가 메모리 동시 접근 경우. 해결방안은 명령어 메모리와 데이터 메로리를 분리.")]),t._v(" "),a("li",[t._v("데이터 의존성 : 이전 명령어 수행결과가 아직 준비되지 않았을 때. 오버플로우 했을 경우에도 발생.")]),t._v(" "),a("li",[t._v("분기 곤란(branch difficulty) : 분기 명령어가 PC의 값을 변경할 때")])])]),t._v(" "),a("li",[a("p",[t._v("분기 명령어 처리")]),t._v(" "),a("ul",[a("li",[t._v("성능 저하의 주 요인")]),t._v(" "),a("li",[t._v("해결방안\n"),a("ul",[a("li",[t._v("순차적으로 처리될 명령어를 분기의 목표가 되는 명령어와 함께 저장해서 해결")]),t._v(" "),a("li",[t._v("분기 목표 버퍼(BTB) : fetch 세그먼트의 associative memory(주소가 아닌 내용으로 검색 가능한 기억장치)로 이전에 실행된 분기 명령어와 분기 목표 명령어를 저장하여 활용.")]),t._v(" "),a("li",[t._v("분기 예측\n"),a("ul",[a("li",[t._v("자주 사용되는 분기 연산은 굉장히 반복적이다.")]),t._v(" "),a("li",[t._v("예측이 맞으면 효과적인데 틀리면 페널티가 발생한다.")])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"risc-processor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#risc-processor"}},[t._v("#")]),t._v(" RISC Processor")]),t._v(" "),a("blockquote",[a("p",[t._v("Reduced Interaction Set Computer. Complex 와 반대. 파이프라인과 잘 맞아 떨어진다.")])]),t._v(" "),a("ul",[a("li",[t._v("특징\n"),a("ul",[a("li",[t._v("실행 명령어 수는 증가해도 처리 시간은 감소 가능")]),t._v(" "),a("li",[t._v("명령어의 1사이클 실행이 목표")]),t._v(" "),a("li",[t._v("온칩캐시(cpu내 메모리)를 둬서 빠르게 한다. 하드웨어적으로 구현.")]),t._v(" "),a("li",[t._v("간단한 명령 코드와 주소 지정 모드 같은걸 하드와이어")]),t._v(" "),a("li",[t._v("신속한 참조를 위해 레지스터 집합")]),t._v(" "),a("li",[t._v("실수 연산처리를 위한 별도의 코프로세서")])])])]),t._v(" "),a("h3",{attrs:{id:"파이프라인-cpu-성능-분석"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파이프라인-cpu-성능-분석"}},[t._v("#")]),t._v(" 파이프라인 CPU 성능 분석")]),t._v(" "),a("ul",[a("li",[t._v("이론적으로는 세그먼트가 많으면 많을수록 좋지만")]),t._v(" "),a("li",[t._v("세그먼트가 일정해야하고")]),t._v(" "),a("li",[t._v("순차적으로 실행되어야 하고")]),t._v(" "),a("li",[t._v("명령어들 사이에 상호 의존성이 없어야 하고")]),t._v(" "),a("li",[t._v("공유 자원의 충돌이 없어야 한다.")])]),t._v(" "),a("h1",{attrs:{id:"_5-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-memory"}},[t._v("#")]),t._v(" 5. Memory")]),t._v(" "),a("h2",{attrs:{id:"메모리-시스템-이해"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#메모리-시스템-이해"}},[t._v("#")]),t._v(" 메모리 시스템 이해")]),t._v(" "),a("ul",[a("li",[t._v("주기억장치 : 램")]),t._v(" "),a("li",[t._v("보조 기억장치 : SSD")]),t._v(" "),a("li",[t._v("캐쉬 메모리 : 현재 진행되고 있는 프로그램이나 사용빈도가 높은 임시데이터 저장")])]),t._v(" "),a("h2",{attrs:{id:"효율적-메모리-관리-정책"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#효율적-메모리-관리-정책"}},[t._v("#")]),t._v(" 효율적 메모리 관리 정책")]),t._v(" "),a("h2",{attrs:{id:"컴퓨터-성능-개선을-위한-메모리-관리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#컴퓨터-성능-개선을-위한-메모리-관리"}},[t._v("#")]),t._v(" 컴퓨터 성능 개선을 위한 메모리 관리")]),t._v(" "),a("h2",{attrs:{id:"다양한-기억장치들에-대한-이해"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#다양한-기억장치들에-대한-이해"}},[t._v("#")]),t._v(" 다양한 기억장치들에 대한 이해")]),t._v(" "),a("h1",{attrs:{id:"_6-io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-io"}},[t._v("#")]),t._v(" 6. IO")]),t._v(" "),a("h2",{attrs:{id:"시스템-버스-구성-및-제어"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#시스템-버스-구성-및-제어"}},[t._v("#")]),t._v(" 시스템 버스 구성 및 제어")]),t._v(" "),a("h2",{attrs:{id:"입출력-연결과-주소-지정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#입출력-연결과-주소-지정"}},[t._v("#")]),t._v(" 입출력 연결과 주소 지정")]),t._v(" "),a("h2",{attrs:{id:"입출력-수행관-인터럽트"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#입출력-수행관-인터럽트"}},[t._v("#")]),t._v(" 입출력 수행관 인터럽트")]),t._v(" "),a("h1",{attrs:{id:"_7-parallel-computing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-parallel-computing"}},[t._v("#")]),t._v(" 7. Parallel Computing")]),t._v(" "),a("h2",{attrs:{id:"멀티-프로세서"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#멀티-프로세서"}},[t._v("#")]),t._v(" 멀티 프로세서")]),t._v(" "),a("h2",{attrs:{id:"시스템-성능-분석과-개선"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#시스템-성능-분석과-개선"}},[t._v("#")]),t._v(" 시스템 성능 분석과 개선")])])}),[],!1,null,null,null);e.default=_.exports}}]);